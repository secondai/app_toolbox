{
  "type": "react_component:0.0.1:local:98912hd89",
  "name": "MainConnectionsComponent",
  "data": {
    "author": "-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCcuXovU+RZy85KMqLakYSH1mdV\nWdpEUtgcXUyGyU5hVeTO7BkV/kxeC2upcxOwNnrBOdsvHI3nrrILgt90/hCSHKzx\nhOFLREorGoKtSEHxI7/SnzzlWtV3gT/IP5GVHIyvuJBx3hCti0dH55DZG8iMGZ2y\ncGpV73Dez3hHmeBh6wIDAQAB\n-----END PUBLIC KEY-----",
    "version": "1",
    "key": "3bbb860a-423e-4670-8beb-8db80027de87",
    "code": "(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      const AceEditor = universe.AceEditor;\n      const ReactResizeDetector = universe.ReactResizeDetector;\n      const RecreateChildOnPropsChange = universe.RecreateChildOnPropsChange;\n      \n      const Link = universe.ReactRouterDomLink;\n      \n      \n      class EmbeddedComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              embeddedComponenthere\n            </div>\n          )\n        }\n      }\n      \n      class ErrorComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        render(){\n          return (\n            <div>\n              ErrorLoading\n            </div>\n          )\n        }\n      }\n      \n      class mycomponent extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {\n            tabMain: 'info',\n            tabSyndicate: 'syndicate_to',\n            filterText: '',\n            groups: [],\n            groupConnections: [],\n            allExternalConnections: [],\n            identityNodeIdsToGroups: {} // will end up being an obj: {identity._id => groupNode}\n          }\n        }\n        \n        componentDidMount(){\n            \n          this.startup();\n            \n        }\n        \n        @autobind\n        async startup(){\n          await this.fetchAll();\n        }\n        \n        @autobind\n        async fetchAll(){\n          await this.fetchGroups();\n          await this.fetchExternalConnections();\n        }\n        \n        @autobind\n        fetchGroups(){\n          \n          return new Promise(async (resolve,reject)=>{\n            \n            this.setState({\n              fetchingGroups: true\n            });\n            \n            let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n              type: 'standard_capability_action:0.0.1:local:298j291bs',\n              data: {\n                action: 'send',\n                options: {\n                  ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                  RequestNode: {\n                    type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                    data: {\n                      actions: [\n                        {\n                          matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                          dataForAction: {\n                            type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                            data: {\n                              matchFunctionNode: {\n                                // query here!\n                                // action_pointer:0.0.1:local:238972ncr\n                                type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                data: {\n                                  code: `(()=>{\n                                    // Action \n                                    // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                    \n                                    let inputNode = INPUT.data.inputNode;\n                                    \n                                    if(inputNode.nodeId){\n                                      return false;\n                                    }\n                                    \n                                    if(inputNode.type.split(':')[0] != 'group_for_sharing'){\n                                      return false;\n                                    }\n                                    \n                                    return inputNode;\n                                    \n                                  })()`\n                                }\n                              },\n                              // expected/allowed schemas for return \n                              // outputSchemas: [\n                              //   'query_result:0.0.1:local:32490usfj23o23f',\n                              //   'internal_error_output:0.0.1:local:32948x2u3cno2c'\n                              // ]\n                            }\n                          }\n                        }\n                      ]\n                      \n                    }\n                  }\n                }\n              }\n            });\n            \n            // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n            let nodes = response.data.actionResponses[0].data;\n            \n            this.setState({\n              groups: nodes,\n              fetchingGroups: false\n            }, resolve);\n            \n          });\n          \n        }\n        \n        @autobind\n        fetchExternalConnections(){\n          \n          return new Promise(async (resolve,reject)=>{\n            \n            this.setState({\n              fetchingConnections: true\n            });\n            \n            let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n              type: 'standard_capability_action:0.0.1:local:298j291bs',\n              data: {\n                action: 'send',\n                options: {\n                  ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                  RequestNode: {\n                    type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                    data: {\n                      actions: [\n                        {\n                          matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                          dataForAction: {\n                            type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                            data: {\n                              matchFunctionNode: {\n                                // query here!\n                                // action_pointer:0.0.1:local:238972ncr\n                                type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                data: {\n                                  code: `(()=>{\n                                    // Action \n                                    // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                    \n                                    let inputNode = INPUT.data.inputNode;\n                                    \n                                    if(inputNode.nodeId){\n                                      return false;\n                                    }\n                                    \n                                    if(inputNode.type.split(':')[0] != 'external_identity'){\n                                      return false;\n                                    }\n                                    \n                                    return inputNode;\n                                    \n                                  })()`\n                                }\n                              },\n                              // expected/allowed schemas for return \n                              // outputSchemas: [\n                              //   'query_result:0.0.1:local:32490usfj23o23f',\n                              //   'internal_error_output:0.0.1:local:32948x2u3cno2c'\n                              // ]\n                            }\n                          }\n                        }\n                      ]\n                      \n                    }\n                  }\n                }\n              }\n            });\n            \n            // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n            console.log('fetchExternalConnections Response:', response);\n            \n            let nodes = response.data.actionResponses[0].data;\n            \n            this.setState({\n              allExternalConnections: nodes,\n              fetchingConnections: false\n            }, this.updateConnectionGroups);\n            \n            resolve(nodes);\n            \n            \n          });\n          \n        }\n        \n        @autobind\n        updateConnectionGroups(){\n          \n          // Updates all connections with correct groups \n          // - probably should cache this? \n          \n          return new Promise(async (resolve,reject)=>{\n            \n            let identityNodeIdsToGroups = {};\n            \n            for(let externalIdentity of this.state.allExternalConnections){\n              \n              // console.log('User:', externalIdentity);\n              identityNodeIdsToGroups[externalIdentity._id] = [];\n              \n              let externalParsed = (externalIdentity.data.identity || ':').split(':');\n              let idType = externalParsed[0];\n              let username = externalParsed[1];\n              let subname;\n              let usernameSplit = username.split('@');\n              if(usernameSplit.length > 1){\n                subname = usernameSplit[0];\n                username = usernameSplit[1];\n              }\n              \n              // console.log('UserParsed:', idType, subname, '@', username);\n              \n              // Evaluate against Group conditions \n              // - order matters! \n              \n              for(let groupNode of this.state.groups){\n                \n                let allow = false;\n              \n                for(let filter of groupNode.data.identities){\n                  \n                  // console.log('identityFilter:', filter);\n                  \n                  switch(filter.type.split(':')[0]){\n                    case 'identity_range': // implied: \"allow\"\n                      // Check matching \n                      if(filter.data.idType == idType){\n                        if(filter.data.username == '*' || filter.data.username == username){\n                          if((!filter.data.subname && !subname) || (filter.data.subname == '*' || filter.data.subname == subname)){\n                            allow = true;\n                          }\n                        }\n                      }\n                      break;\n                    \n                    case 'identity_range_deny': \n                      // Check matching \n                      if(filter.data.idType == idType){\n                        if(filter.data.username == '*' || filter.data.username == username){\n                          if((!filter.data.subname && !subname) || (filter.data.subname == '*' || filter.data.subname == subname)){\n                            allow = false;\n                          }\n                        }\n                      }\n                      break;\n                      \n                    default:\n                      console.error('Invalid identity_range type for matching!');\n                      break;\n                  }\n                  \n                }\n                \n                if(allow){\n                  identityNodeIdsToGroups[ externalIdentity._id ].push(groupNode);\n                }\n              }\n              \n            }\n            \n            this.setState({\n              identityNodeIdsToGroups\n            });\n            \n            \n          });\n          \n        }\n        \n        @autobind\n        handleViewConnection(externalIdentityNode){\n          this.setState({\n            externalIdentityNodeId: externalIdentityNode._id\n          },this.updateConnectionGroups);\n        }\n        \n        @autobind\n        handleAddToGroup(groupNode){\n          \n          // Add an individual identity to a group \n          \n          return new Promise(async (resolve,reject)=>{\n            \n            // Get type of restriction for group \n            // - who to allow/deny for inclusion \n            //   - matched identities or provided info (token provided) \n            \n            let matchType;\n            // let matchType = WINDOW.prompt('match type (identity_range):','identity_range');\n            // if(!matchType){\n            //   return false;\n            // }\n            \n            let idType = WINDOW.prompt('idType (id, idtest, * for anything):','*');\n            if(typeof idType != 'string'){\n              return false\n            }\n            let username = WINDOW.prompt('username (* for anything, subname@username):','*');\n            if(typeof username != 'string'){\n              return false\n            }\n            \n            let subname = ''; // empty is for root \n            let usernameSplit = username.split('@');\n            if(usernameSplit.length > 1){\n              subname = usernameSplit[0];\n              username = usernameSplit[1];\n            }\n            \n            if(username == '*'){\n              subname = '*';\n            }\n            \n            matchType = \"identity_range:Qmsfljlkjs329f\";\n            if(includeOrExclude == 'exclude'){\n              matchType = \"identity_range_deny:Qmsdfj9823jf923f\";\n            }\n            \n            // only \"identity_range\" types for now \n            let matchNode = {\n              type: matchType, \n              data: {\n                idType,\n                username,\n                subname\n              }\n            }\n            \n            groupNode.data.identities.push(matchNode);\n            \n            console.log('Updating groupNode:', groupNode);\n            \n            \n            let updatedNode = await this.makeSaveRequest(groupNode);\n            \n            await this.fetchGroups();\n            \n          });\n            \n        }\n        \n        @autobind\n        handleAddDataRule(externalIdentityNode, syndicationInfoNode){\n          \n          // Adds a new Data Rule to the syndication rules \n          // - data rules take the \"shared_node\" as input \n          // - matching is done using underscore-query (mongo-like matching) \n          \n          return new Promise(async (resolve,reject)=>{\n            \n            // Get type of restriction for group \n            // - who to allow/deny for inclusion \n            //   - matched identities or provided info (token provided) \n            \n            // let matchType = 'data_match_mongolike';\n            // let matchType = WINDOW.prompt('match type (allow_group, allow_identity):','identity_range');\n            // if(!matchType){\n            //   return false;\n            // }\n            \n            // let nodeType = 'data_match_mongolike';\n            let nodeType = WINDOW.prompt('Match shared_node data of type (* for all):','*');\n            if(!nodeType){\n              return false;\n            }\n            \n            let name;\n            \n            if(nodeType == '*'){\n              nodeType = '';\n              name = `All shared_nodes`;\n            } else {\n              name = `shared_node type: \"${nodeType}\"`;\n            }\n            \n            \n            let query = {\n              // type of \n              'data.type': {\n                $like: `${nodeType}:` // \":\" matches everything\n              }\n            };\n            \n            // only \"identity_range\" types for now \n            let matchNode = {\n              type: 'data_match_mongolike:Qmf32jsd8222fwea', \n              data: {\n                name,\n                query: JSON.stringify(query) // required because of dotted keys \n              }\n            }\n            \n            syndicationInfoNode.data.dataRules.push(matchNode);\n            \n            console.log('Updating syndicationInfoNode:', syndicationInfoNode);\n            \n            let updatedNode = await this.makeSaveRequest(syndicationInfoNode);\n            \n            await this.fetchAll(); // TODO: unnecessary? \n            \n          });\n            \n        }\n        \n        @autobind\n        handleAddIdentityRule(externalIdentityNode, syndicationInfoNode){\n          \n          // Adds a new Identity Rule to the syndication rules (only 1 allowed for now) \n          // - a match of a group for the shared_node permissions childNode means it will be syndicated \n          // - TODO: identities, more complex attributes \n          \n          \n          return new Promise(async (resolve,reject)=>{\n            \n            // Choose group to syndicate information for \n            let groupName = WINDOW.prompt('Group Name:','Public');\n            if(!groupName){\n              return false;\n            } \n            \n            let group = universe.lodash.find(this.state.groups, {data:{name: groupName}});\n            if(!group){\n              WINDOW.alert('Unable to find group');\n              console.log(this.state.groups);\n              return false;\n            }\n            \n            let name = `allow_group: \"${group.data.name}\"`;\n            // query is against a type: \"allow_group:Qmdskfj320fsfn\" \n            let query = {\n              // type of \n              'data.rules': {\n                $elemMatch: {\n                  'type': {\n                    $like: 'allow_group:'\n                  },\n                  'data.groupKey': group.data.key\n                }\n              }\n            };\n            \n            let matchNode = {\n              type: 'syndicate_group_allowed:Qmf3829hh2398h', \n              data: {\n                name,\n                query: JSON.stringify(query) // required because of dotted keys \n              }\n            }\n            \n            syndicationInfoNode.data.identityRules.push(matchNode);\n            \n            console.log('Updating syndicationInfoNode:', syndicationInfoNode);\n            \n            let updatedNode = await this.makeSaveRequest(syndicationInfoNode);\n            \n            await this.fetchGroups();\n            \n          });\n            \n        }\n        \n        \n        @autobind\n        async handleAddSyndication(externalIdentityNode){\n          \n          this.setState({\n            modifyingSyndication: true\n          });\n          \n          let newNode = {\n            nodeId: externalIdentityNode._id,\n            name: universe.uuidv4(),\n            type: 'syndication_info:Qmsdlfjk23ji',\n            data: {\n              // allowRules: [], // combination of dataRules and identityRules. if ANY match, syndicate content (preferable to separate dataRules and identityRules) \n              dataRules: [], // for matching content of shared_nodes \n              identityRules: [] // uses group uuids\n            }\n          }\n          console.log('newNode for syndication_info', newNode);\n          let savedNode = await this.forceNewNode(newNode, {skipExistingLearnedNodeId: true});\n          \n          await this.fetchExternalConnections();\n          \n          this.setState({\n            modifyingSyndication: false\n          });\n          \n        }\n        \n        \n        @autobind\n        async handleAddGroupToSyndication(externalIdentityNode){\n        \n          let groupName = WINDOW.prompt('Group Name:','Public');\n          if(!groupName){\n            return false;\n          } \n          \n          let groupNode = universe.lodash.find(this.state.groups, {data:{name: groupName}});\n          if(!groupNode){\n            WINDOW.alert('Unable to find group');\n            console.log(this.state.groups);\n            return false;\n          }\n          \n          if(!groupNode.data.key){\n            WINDOW.alert('Missing unique key for groupNode');\n            return false;\n          }\n          \n          this.setState({\n            modifyingSyndication: true\n          });\n          \n          let newNode = {\n            nodeId: externalIdentityNode._id,\n            name: universe.uuidv4(),\n            type: 'syndication_group:Qmf239jsdfjjnkf23',\n            data: {\n              groupKey: groupNode.data.key\n            }\n          }\n          console.log('newNode for syndication_group', newNode);\n          let savedNode = await this.forceNewNode(newNode, {skipExistingLearnedNodeId: true});\n          \n          await this.fetchExternalConnections();\n          \n          this.setState({\n            modifyingSyndication: false\n          });\n          \n        }\n        \n        \n        @autobind\n        async handleAddSyndicationFrom(externalIdentityNode){\n          \n          this.setState({\n            modifyingSyndication: true\n          });\n          \n          let newNode = {\n            nodeId: externalIdentityNode._id,\n            name: universe.uuidv4(),\n            type: 'syndication_from_info:Qmsdkfj329jdsf',\n            data: {\n              // allowRules: [], // combination of dataRules and identityRules. if ANY match, syndicate content (preferable to separate dataRules and identityRules) \n              dataRules: [], // for matching content of shared_nodes \n              // identityRules: [] // uses group uuids\n            }\n          }\n          console.log('newNode for syndication_from_info', newNode);\n          let savedNode = await this.forceNewNode(newNode, {skipExistingLearnedNodeId: true});\n          \n          await this.fetchExternalConnections();\n          \n          this.setState({\n            modifyingSyndication: false\n          });\n          \n        }\n        \n        @autobind\n        async handleRemoveSyndication(externalIdentityNode, syndicationNode){\n          \n          this.setState({\n            modifyingSyndication: true\n          });\n          \n          syndicationNode.active = false;\n          \n          let updatedNode = await this.makeSaveRequest(syndicationNode);\n            \n          await this.fetchAll();\n          \n          this.setState({\n            modifyingSyndication: false\n          });\n          \n        }\n        \n        @autobind\n        async handleRemoveGroupSyndication(externalIdentityNode, syndicationGroupNode){\n          \n          this.setState({\n            modifyingSyndication: true\n          });\n          \n          syndicationGroupNode.active = false;\n          \n          let updatedNode = await this.makeSaveRequest(syndicationGroupNode);\n            \n          await this.fetchAll();\n          \n          this.setState({\n            modifyingSyndication: false\n          });\n          \n        }\n        \n        @autobind\n        async handleUpdateSyndicates(){\n          \n          this.setState({\n            updatingSyndicates: true\n          })\n          \n          // Make request to save Node on remote \n          try {\n            \n            let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n              type: 'standard_capability_action:0.0.1:local:298j291bs',\n              data: {\n                action: 'send',\n                options: {\n                  ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                  RequestNode: {\n                    type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                    data: {\n                      actions: [\n                        {\n                          matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                          dataForAction: {\n                            type: 'string:...',\n                            data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                          }\n                        },\n                        \n                        {\n                          matchActionType: 'update_syndication_info:Qm23f92j39h2hdsqw',\n                          dataForAction: {}\n                        }\n                      ]\n                      \n                    }\n                  }\n                }\n              }\n            });\n            \n            console.log('Updated syndicates');\n            \n          }catch(err){\n            console.error('Failed updating syndicates');\n          }\n          \n          this.setState({\n            updatingSyndicates: false\n          });\n              \n        }\n        \n        @autobind\n        async handleAddConnection(){\n          let networkAndUsername = WINDOW.prompt('network:username (idtest:test1)','idtest:');\n          if(!networkAndUsername){\n            return false;\n          }\n          let networkAndUsernameSplit = networkAndUsername.split(':');\n          if(networkAndUsernameSplit.length != 2){\n            WINDOW.alert('Invalid input');\n            return false;\n          }\n          let network = networkAndUsernameSplit[0].trim();\n          let username = networkAndUsernameSplit[1].trim();\n          \n          let opts = {};\n          switch(network){\n            case 'id':\n              opts = {\n                address: 'https://horizon.stellar.org',\n                network: 'public',\n              }\n              break;\n            case 'idtest':\n              opts = {\n                address: 'https://horizon-testnet.stellar.org',\n                network: 'test',\n              }\n              break;\n            default:\n              console.error('Invalid network type, expecting id or idtest');\n              return false;\n          }\n          \n          this.setState({\n            addingConnection: true\n          });\n          \n          let Friend_ExternalIdentityNode = await universe.getSecondForUsername(username,opts);\n          \n          // Update to include identity (in case not included by remote) \n          Friend_ExternalIdentityNode.data.identity = networkAndUsername;\n          \n          // // Need to create a local Identity, and authenticate with the remote Second to Learn from \n          // // - uses a constant value (token) from the remote Second! \n          // let addressNode = await universe.loadAndRunCapability('Identity',{},{\n          //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n          //   data: {\n          //     action: 'getAddressForWords',\n          //     options: {\n          //       words\n          //     }\n          //   }\n          // });\n          \n          // let address = addressNode.data;\n          \n          // console.log('Address:', address);\n          \n          // let Friend_ExternalIdentityNode = await universe.getIdentityForAddress(address);\n          \n          console.log('MySecond:', this.props.state.OwnerSecondExternalIdentityNode);\n          console.log('FriendSecond', Friend_ExternalIdentityNode);\n          \n          \n          // Make TalkToSecond request to Identify MySecond with remote \n          let connectionResponse = await universe.loadAndRunCapability('TalkToSecond',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'send',\n              options: {\n                ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                RequestNode: {\n                  type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                  data: {\n                    actions: [\n                      {\n                        matchActionType: 'identify_challenge_initiate:0.0.1:local:8239hf28hf283h',\n                        dataForAction: {\n                          type: 'challenge_init_remote:0.0.1:...',\n                          data: {\n                            ExternalIdentityNode: Friend_ExternalIdentityNode\n                          }\n                        }\n                      }\n                    ]\n                    \n                  }\n                }\n              }\n            }\n          });\n          \n          console.log('Friend Connection Response:', connectionResponse);\n          \n          let responseNode = connectionResponse.data.actionResponses[0];\n          \n          this.setState({\n            addingConnection: false\n          });\n          \n          // if added, include an internal \"basic data\" node \n          // - tags? \n          if(responseNode.data.result){\n            \n            let newExternalMetadata = {\n              nodeId: responseNode.data.node._id,\n              type: 'external_metadata:dslfjdklj',\n              data: {\n                identity: networkAndUsername,\n                tags: []\n              }\n            }\n            console.log('newExternalMetadata', newExternalMetadata);\n            let savedNode = await this.forceNewNode(newExternalMetadata, {skipExistingLearnedNodeId: true});\n            \n          } else {\n            WINDOW.alert('Failed Adding Connection');\n          }\n          \n          \n          await this.fetchExternalConnections();\n          \n        }\n        \n        @autobind\n        forceNewNode(nodeToSave, opts, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            console.log('NewNode:', nodeToSave);\n                \n            // return resolve({\n            //   saveNewNode: nodeToSave\n            // });\n            \n            \n            // Make request to save Node on remote \n            try {\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                            dataForAction: {\n                              type: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                              data: {\n                                optionsNode: {\n                                  type: 'options_generic:0.0.1:local:289f3j29832',\n                                  data: opts || {}\n                                },\n                                dataNode: nodeToSave\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('NewNode response:', response);\n              \n              // get the new node \n              let savedNode = response.data.actionResponses[0];\n              \n              // console.log('Saved Node:', savedNode);\n              \n              if(skipEvent !== true){\n                try {\n                  universe.EE.emit('nodes-modified', '');\n                }catch(err){\n                  console.error(err);\n                }\n              }\n              \n              return resolve(savedNode);\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              // alert('Failed');\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        makeSaveRequest(nodeToSave, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            this.setState({\n              saving: true\n            })\n            \n            // Make request to save Node on remote \n            try {\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'update_node:0.0.1:local:392821982y3',\n                            dataForAction: {\n                              type: 'node:0.0.1:local:123445',\n                              data: nodeToSave\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('Update response:', response);\n              \n              if(skipEvent !== true){\n                try {\n                  universe.EE.emit('nodes-modified', '');\n                }catch(err){\n                  console.error(err);\n                }\n              }\n              \n              this.setState({\n                saving: false\n              })\n              \n              return resolve({\n                type: 'node:...',\n                data: response.data.actionResponses[0]\n              });\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              alert('Failed');\n              \n              this.setState({\n                saving: false\n              })\n              \n              return reject();\n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        renderConnections(){\n          let identityNodeIdsToGroups = this.state.identityNodeIdsToGroups;\n          return this.state.allExternalConnections.filter(externalIdentityNode=>{\n            // // require the identity to exist?\n            // return externalIdentityNode.data.identity;\n            // return true;\n            let {\n              filterText\n            } = this.state;\n            \n            if(filterText && filterText.length){\n              if(externalIdentityNode.data.identity && externalIdentityNode.data.identity.indexOf(filterText) > -1){\n                return true;\n              }\n            } else {\n              return true;\n            }\n            \n            return false;\n            \n          }).map(externalIdentityNode=>{\n            return this.renderConnectionSmall(externalIdentityNode);\n          })\n          \n        }\n        \n        @autobind\n        renderConnectionSmall(externalIdentityNode){\n          let identityNodeIdsToGroups = this.state.identityNodeIdsToGroups;\n        \n          return (\n            <div key={externalIdentityNode._id} className=\"box\">\n              \n              <h3 className=\"title is-5\" onClick={e=>this.handleViewConnection(externalIdentityNode)} style={{cursor:'pointer'}}>\n                {externalIdentityNode.data.identity || 'Ephemeral Identity'}\n              </h3>\n              \n              <div>\n                {\n                  !(identityNodeIdsToGroups[externalIdentityNode._id] || []).length ? \n                    <small>not part of any groups</small>\n                  :\n                    <div className=\"tags\">\n                      {\n                        (identityNodeIdsToGroups[externalIdentityNode._id] || []).map(groupNode=>(\n                          <span key={groupNode._id} className=\"tag is-light\">{groupNode.data.name}</span>\n                        ))\n                      }\n                    </div>\n                }\n                              \n              </div>\n              \n            </div>\n          )\n        }\n        \n        @autobind\n        renderConnectionBig(){\n          // Render info for the selected group \n            \n          if(!this.state.externalIdentityNodeId){\n            return '';\n          }\n          \n          let externalIdentityNode = this.state.allExternalConnections.find(e=>{return e._id == this.state.externalIdentityNodeId});\n          \n          if(!externalIdentityNode){\n            return (\n              <div>\n                Unable to load connection! \n              </div>\n            )\n          }\n          \n          let identityNodeIdsToGroups = this.state.identityNodeIdsToGroups;\n          \n          \n          // invalid identity? (ephemeral/browser connection?) \n          if(!externalIdentityNode.data.identity){\n            return (\n              <div>\n                <h3 className=\"title is-3\">\n                  Emphemeral Identity\n                </h3>\n                <h3 className=\"subtitle is-6\">\n                  created {externalIdentityNode.createdAt}\n                </h3>\n                \n                <hr />\n                \n                <p>\n                  Ephemeral identities (such as browser connections) should still have an identity...\n                </p>\n                \n              </div>\n            )\n          }\n          \n          \n          let tabsMain = [\n            ['info','Info'],\n            ['syndicate', 'Syndicate Data'],\n          ];\n          \n          let tabsSyndicate = [\n            ['syndicate_to', 'To'],\n            ['syndicate_from','From'],\n          ];\n          \n\n          // TO \n          \n          // expecting a single syndication node! \n          // - if multiple should error? \n          let syndicationNodes = (externalIdentityNode.nodes || []).filter(node=>{\n            return node.type.split(':')[0] == 'syndication_info';\n          });\n          \n          // groups that the syndication \"knows\" about (build identity for permissions) \n          let syndicationGroupNodes = (externalIdentityNode.nodes || []).filter(node=>{\n            return node.type.split(':')[0] == 'syndication_group';\n          });\n          \n          // FROM \n          \n          // expecting a single syndication node! \n          // - if multiple should error? \n          let syndicationFromNodes = (externalIdentityNode.nodes || []).filter(node=>{\n            return node.type.split(':')[0] == 'syndication_from_info';\n          });\n          \n          \n          return (\n            <div>\n            \n              <h3 className=\"title is-3\">\n                {externalIdentityNode.data.identity}\n                \n              </h3>\n              <h3 className=\"subtitle is-6\">\n                Connected: {universe.moment(externalIdentityNode.createdAt,'x').format('LLLL')}\n              </h3>\n              \n              \n              <div className=\"tabs\">\n                <ul>\n                  {\n                    tabsMain.map(tab=>(\n                      <li key={tab[0]}\n                        onClick={e=>this.setState({tabMain:tab[0]})}\n                        className={(this.state.tabMain == tab[0]) ? 'is-active':''}\n                        ><a>{tab[1]}</a></li>\n                    ))\n                  }\n                </ul>\n              </div>\n              \n              \n              {/* info/groups */}\n              <div style={(this.state.tabMain != 'info') ? {display:'none'}:{}}>\n                \n                <div>\n                  <h3 className=\"title is-4\">\n                    Groups\n                  </h3>\n                  \n                  <div>\n                    {\n                      !(identityNodeIdsToGroups[externalIdentityNode._id] || []).length ? '':\n                      \n                      <div className=\"tags\">\n                        {\n                          (identityNodeIdsToGroups[externalIdentityNode._id] || []).map(groupNode=>(\n                            <span key={groupNode._id} className=\"tag is-light\">{groupNode.data.name}</span>\n                          ))\n                        }\n                      </div>\n                    }\n                  </div>\n                    \n                </div>\n                \n              </div>\n              \n              \n              \n              {/* Syndication info */}\n              <div style={(this.state.tabMain != 'syndicate') ? {display:'none'}:{}}>\n                \n                \n                <h3 className=\"title is-4\">\n                  Syndication\n                  \n                  {\n                    !this.state.modifyingSyndication ? '':\n                    <button className=\"button is-loading is-small\">\n                      &nbsp;\n                    </button>\n                  }\n                  \n                </h3>\n              \n                <p>\n                  When syndicating shared_node's, apply Data Rule to shared_node, and Identity Rule to the permissions allowed. \n                  <br />\n                  shared_node's permissions often require knowledge of Groups, which you can also syndicate. Missing Groups will likely result in a shared_node NOT being available to your intended audience! \n                </p>\n                \n                \n                <div className=\"tabs\">\n                  <ul>\n                    {\n                      tabsSyndicate.map(tab=>(\n                        <li key={tab[0]}\n                          onClick={e=>this.setState({tabSyndicate:tab[0]})}\n                          className={(this.state.tabSyndicate == tab[0]) ? 'is-active':''}\n                          ><a>{tab[1]}</a></li>\n                      ))\n                    }\n                  </ul>\n                </div>\n                \n                \n                \n                <div style={(this.state.tabSyndicate != 'syndicate_to') ? {display:'none'}:{}}>\n              \n                  <h3 className=\"subtitle is-6\">\n                    Your shared data, on a remote Second \n                  </h3>\n                  \n                  <div>\n                    <table className=\"table is-narrow is-fullwidth\">\n                      <thead>\n                        <th>\n                          Groups (synced for evaluating permissions)\n                        </th>\n                        <th></th>\n                      </thead>\n                      <tbody>\n                      \n                        {\n                          syndicationGroupNodes.map(syndicationGroupNode=>{\n                            \n                            let groupNode = universe.lodash.find(this.state.groups, {data:{key: syndicationGroupNode.data.groupKey}});\n                            \n                            return (\n                              <tr key={syndicationGroupNode._id}>\n                                <td>\n    \n                                  <div>\n                                    {\n                                      groupNode ? \n                                      groupNode.data.name : '--Unknown Group--'\n                                    }\n                                  </div>\n                                </td>\n                                <td>\n                                \n                                  <span className=\"delete\" onClick={e=>this.handleRemoveGroupSyndication(externalIdentityNode, syndicationGroupNode)}></span>\n                                \n                                </td>\n                              </tr>\n                              )\n                            }\n                          )\n                        }\n                        <tr>\n                          <td colSpan=\"3\">\n                            <div className=\"has-text-centered\">\n                              <button className=\"button is-default is-small\" onClick={e=>this.handleAddGroupToSyndication(externalIdentityNode)}>\n                                + Group \n                              </button>\n                            </div>\n                          </td>\n                        </tr>\n                        \n                      </tbody>\n                    </table>\n                  </div>\n                  \n                  <div>\n                    <table className=\"table is-narrow is-fullwidth\">\n                      <thead>\n                        <th>\n                          Data Rule\n                        </th>\n                        <th>\n                          Identity Rule (for Group) \n                        </th>\n                        <th></th>\n                      </thead>\n                      <tbody>\n                      \n                        {\n                          syndicationNodes.map(syndicationNode=>(\n                            <tr key={syndicationNode._id}>\n                              <td>\n                                <div>\n                                  {\n                                    syndicationNode.data.dataRules.map((dataRule,dataRuleIdx)=>{\n                                      if(dataRule.type.indexOf('data_match_mongolike:') === -1){\n                                        console.error('Invalid dataRule type', dataRule.type);\n                                        return null;\n                                      }\n                                      return (\n                                        <div key={dataRuleIdx}>\n                                          {dataRule.data.name}\n                                        </div>\n                                      )\n                                    })\n                                  }\n                                  {\n                                    syndicationNode.data.dataRules.length ? '':\n                                    <div>\n                                      <button className=\"button is-default is-small\" onClick={e=>this.handleAddDataRule(externalIdentityNode, syndicationNode)}>\n                                        + Data Rule  \n                                      </button>\n                                    </div>\n                                  }\n                                </div>\n                              </td>\n                              \n                              {/* Identity Rule(s) */}\n                              <td>\n  \n                                <div>\n                                  {\n                                    syndicationNode.data.identityRules.map((identityRule,identityRuleIdx)=>{\n                                      if(identityRule.type.indexOf('syndicate_group_allowed:') === -1){\n                                        console.error('Invalid identityRule type', identityRule.type);\n                                        return null;\n                                      }\n                                      return (\n                                        <div key={identityRuleIdx}>\n                                          {identityRule.data.name}\n                                        </div>\n                                      )\n                                    })\n                                  }\n                                  {\n                                    syndicationNode.data.identityRules.length ? '' :\n                                    <div>\n                                      <button className=\"button is-default is-small\" onClick={e=>this.handleAddIdentityRule(externalIdentityNode, syndicationNode)}>\n                                        + Identity Rule  \n                                      </button>\n                                    </div>\n                                  }\n                                </div>\n                              </td>\n                              <td>\n                              \n                                <span className=\"delete\" onClick={e=>this.handleRemoveSyndication(externalIdentityNode, syndicationNode)}></span>\n                              \n                              </td>\n                            </tr>\n                          ))\n                        }\n                        <tr>\n                          <td colSpan=\"3\">\n                            <div className=\"has-text-centered\">\n                              <button className=\"button is-default is-small\" onClick={e=>this.handleAddSyndication(externalIdentityNode)}>\n                                + Syndication Rule \n                              </button>\n                            </div>\n                          </td>\n                        </tr>\n                      </tbody>\n                    </table>\n                    \n                  </div>\n                  \n                  <div>\n                    \n                    <h3 className=\"title is-6\">\n                      Payment\n                    \n                      &nbsp;\n                      \n                      {\n                        !this.state.loadingSyndicatedData ? '':\n                        <button className=\"button is-loading is-small\">\n                          &nbsp;\n                        </button>\n                      }\n                      \n                    </h3>\n                    \n                    <p>\n                      <i>No payment setup for syndication</i>\n                    </p>\n                    \n                    <div>\n                    \n                      <button className=\"button is-default is-small\">\n                        Use Advertising Profile\n                      </button>\n                      \n                      &nbsp;\n                      \n                      <button className=\"button is-default is-small\">\n                        Setup Escrow Balance\n                      </button>\n                      \n                    </div>\n                    \n                  </div>\n                  \n                  <br />\n                  <br />\n                  \n                  <h3 className=\"title is-6\">\n                    Syndicated Data\n                  \n                    &nbsp;\n                    \n                    {\n                      !this.state.loadingSyndicatedData ? '':\n                      <button className=\"button is-loading is-small\">\n                        &nbsp;\n                      </button>\n                    }\n                    \n                  </h3>\n                  \n                  <div>\n                  \n                    <button className=\"button is-default is-small\">\n                      Browse Syndicated Data\n                    </button>\n                    \n                    &nbsp;\n                    \n                    <button className=\"button is-danger is-small\">\n                      Revoke All Syndicated Data \n                    </button>\n                    \n                  </div>\n                  \n                  \n                </div>\n                  \n                <div style={(this.state.tabSyndicate != 'syndicate_from') ? {display:'none'}:{}}>\n                  \n                  \n                  <h3 className=\"subtitle is-6\">\n                    Provide limits on what you're willing to syndicate for someone else \n                  </h3>\n                  \n                  <div>\n                    <table className=\"table is-narrow is-fullwidth\">\n                      <thead>\n                        <th>\n                          Data Rule\n                        </th>\n                        <th></th>\n                      </thead>\n                      <tbody>\n                      \n                        {\n                          syndicationFromNodes.map(syndicationNode=>(\n                            <tr key={syndicationNode._id}>\n                              <td>\n                                <div>\n                                  {\n                                    syndicationNode.data.dataRules.map((dataRule,dataRuleIdx)=>{\n                                      if(dataRule.type.indexOf('data_match_mongolike:') === -1){\n                                        console.error('Invalid dataRule type', dataRule.type);\n                                        return null;\n                                      }\n                                      return (\n                                        <div key={dataRuleIdx}>\n                                          {dataRule.data.name}\n                                        </div>\n                                      )\n                                    })\n                                  }\n                                  {\n                                    syndicationNode.data.dataRules.length ? '':\n                                    <div>\n                                      <button className=\"button is-default is-small\" onClick={e=>this.handleAddDataRule(externalIdentityNode, syndicationNode)}>\n                                        + Data Rule  \n                                      </button>\n                                    </div>\n                                  }\n                                </div>\n                              </td>\n                              \n                              <td>\n                              \n                                <span className=\"delete\" onClick={e=>this.handleRemoveSyndication(externalIdentityNode, syndicationNode)}></span>\n                              \n                              </td>\n                            </tr>\n                          ))\n                        }\n                        <tr>\n                          <td colSpan=\"3\">\n                            <div className=\"has-text-centered\">\n                              <button className=\"button is-default is-small\" onClick={e=>this.handleAddSyndicationFrom(externalIdentityNode)}>\n                                + Syndication Rule \n                              </button>\n                            </div>\n                          </td>\n                        </tr>\n                      </tbody>\n                    </table>\n                    \n                  </div>\n                  \n                  \n                  <h3 className=\"title is-6\">\n                    Syndicated Data\n                  \n                    &nbsp;\n                    \n                    {\n                      !this.state.loadingSyndicatedData ? '':\n                      <button className=\"button is-loading is-small\">\n                        &nbsp;\n                      </button>\n                    }\n                    \n                  </h3>\n                  \n                  <div>\n                  \n                    <button className=\"button is-default is-small\">\n                      Browse Syndicated Data\n                    </button>\n                    \n                  </div>\n                  \n                </div>\n                \n              </div>\n              \n            </div>\n          )\n          \n        }\n        \n        render(){\n          \n          return (\n            <div className=\"container\">\n              <div className=\"columns\">\n                <div className=\"column is-4\">\n                \n                  <br />\n                  \n                  <div className=\"level\">\n                    <div className=\"level-left\">\n                      <div className=\"level-item\">\n                        <button className=\"button is-info\" onClick={this.handleAddConnection}>\n                          + Connection \n                        </button>\n                      </div>\n                      <div className=\"level-item\">\n                    \n                        <div className=\"field has-addons\">\n                          <div className=\"control\">\n                            <button className=\"button\" onClick={this.fetchAll}>\n                              Fetch Latest\n                            </button>\n                          </div>\n                          {\n                            (!this.state.fetchingGroups && !this.state.fetchingConnections) ? '':\n                            <div className=\"control\">\n                              <a className=\"button is-loading\">\n                                &nbsp;\n                              </a>\n                            </div>\n                          }\n                        </div>\n                      </div>\n                      <div className=\"level-item\">\n                    \n                        <div className=\"field has-addons\">\n                          <div className=\"control\">\n                            <button className=\"button\" onClick={this.handleUpdateSyndicates}>\n                              Update Syndicates\n                            </button>\n                          </div>\n                          {\n                            (!this.state.updatingSyndicates) ? '':\n                            <div className=\"control\">\n                              <a className=\"button is-loading\">\n                                &nbsp;\n                              </a>\n                            </div>\n                          }\n                        </div>\n                        \n                      </div>\n                    </div>\n                    \n                  </div>\n                \n                  <hr />\n                  \n                      \n                  <div>\n                    <input className=\"input\" value={this.state.filterText} onChange={e=>this.setState({filterText:e.target.value})} placeholder=\"Filter\" />\n                  </div>\n                  \n                  <br />\n                  \n                  <div>\n                    {\n                      this.renderConnections()\n                    }\n                  </div>\n                  \n                </div>\n                \n                <div className=\"column is-8\">\n                  {\n                    this.renderConnectionBig()\n                  }\n                </div>\n                \n              </div>\n              \n            </div>\n          )\n        }\n      }\n      \n      mycomponent = universe.ReactGlobalState(mycomponent);\n      mycomponent = universe.ReactHelpers(mycomponent);\n      \n      const styles = {\n        deleteIcon: {\n          position: 'absolute',\n          top: '0px',\n          right: '-24px',\n          cursor: 'pointer'\n        }\n      }\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: mycomponent\n      });\n      \n    }catch(err){\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()",
    "internalId": "MainConnectionsComponent"
  }
}