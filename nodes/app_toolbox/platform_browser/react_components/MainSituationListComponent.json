{
  "type": "react_component:0.0.1:local:98912hd89",
  "name": "MainSituationListComponent",
  "data": {
    "author": "-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCcuXovU+RZy85KMqLakYSH1mdV\nWdpEUtgcXUyGyU5hVeTO7BkV/kxeC2upcxOwNnrBOdsvHI3nrrILgt90/hCSHKzx\nhOFLREorGoKtSEHxI7/SnzzlWtV3gT/IP5GVHIyvuJBx3hCti0dH55DZG8iMGZ2y\ncGpV73Dez3hHmeBh6wIDAQAB\n-----END PUBLIC KEY-----",
    "version": "1",
    "key": "MainSituationListComponent",
    "code": "(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      const AceEditor = universe.AceEditor;\n      const ReactResizeDetector = universe.ReactResizeDetector;\n      const RecreateChildOnPropsChange = universe.RecreateChildOnPropsChange;\n      \n      const Select = universe.ReactSelect;\n      \n      const ReactSortableContainer = universe.ReactSortableContainer;\n      const ReactSortableElement = universe.ReactSortableElement;\n      const ReactSortableArrayMove = universe.ReactSortableArrayMove;\n      \n      // // // const SelectCSS = universe.require('react-select/dist/react-select.css');\n      // await universe.$.getScript('https://unpkg.com/react@15.6.1/dist/react.js');\n      // await universe.$.getScript('https://unpkg.com/react-dom@15.6.1/dist/react-dom.js');\n      // await universe.$.getScript('http://localhost:8080/standalone/invariant');\n      // await universe.$.getScript('https://unpkg.com/react-sortable-hoc@0.8.3/dist/umd/react-sortable-hoc.js');\n      \n      // // await universe.RequireFromUnpkg('react-reorder');\n          \n      class SortableItem extends React.Component {\n        constructor(props){\n          super(props);\n          \n          let node = this.props.value;\n          \n          this.state = {\n            node,\n            editing: false,\n          }\n        }\n        \n        componentDidMount(){\n          this.handleKeyDown();\n        }\n        \n        \n        @autobind\n        startEditing(){\n          console.log('startEditing', this.state.node);\n          \n          let query;\n          try {\n            query = JSON.stringify(JSON.parse(this.state.node.data.query), null, 2);\n          }catch(err){\n            console.error('invalid query value! not a string (should have been):', this.state.node, err);\n            query = 'ERROR!'\n          }\n          \n          this.setState({\n            editing: true,\n            value: query\n          });\n        }\n        \n        @autobind\n        closeEditor(){\n          this.setState({\n            editing: false\n          });\n        }\n        \n        @autobind\n        handleSave(){\n          console.log('saving');\n          \n          // Verify it is an object (not an array) \n          let query;\n          let value = this.state.value;\n          try {\n            // todo: dirty-json! \n            query = JSON.stringify(JSON.parse(value));\n          }catch(err){\n            console.error('Invalid JSON');\n            WINDOW.alert('Invalid JSON');\n            return false;\n          }\n          \n          console.log('Query:', query);\n          \n        }\n      \n        @autobind\n        handleKeyDown(e){\n          if(this.aceRef && this.aceRef.editor){\n            this.aceRef.editor.commands.addCommand({\n              name: 'save',\n              bindKey: {\n                win: 'Ctrl-S',\n                mac: 'Command-S'\n              },\n              exec: (env, args, request)=>{\n                this.handleSave();\n              }\n            });\n            \n            // overwrite Cmd-D to same as sublime \n            this.aceRef.editor.commands.addCommand({\n              name: 'selectMoreAfter2',\n              bindKey: {\n                win: 'Ctrl-D',\n                mac: 'Command-D'\n              },\n              exec: (env, args, request)=>{\n                // selectMoreAfter\n                this.aceRef.editor.execCommand(\"selectMoreAfter\")\n              }\n            });\n          }\n      \n        }\n        \n        render(){\n          let node = this.state.node;\n          \n          return (\n            <div>\n              {(node.data.position || 0) + 1}. \"{\n                node.data.plain\n              }\" <span className='icon' onClick={this.startEditing}><i className='fa fa-edit'></i></span>\n              { !this.state.editing ? '':\n              <div>\n                <div style={{height: '300px'}}>\n                  <AceEditor\n                    ref={r=>this.aceRef=r}\n                    mode=\"jsx\"\n                    theme=\"monokai\"\n                    value={this.state.value}\n                    onChange={value=>{\n                      this.setState({value});\n                    }}\n                    editorProps={{$blockScrolling: true}}\n                    width=\"100%\"\n                    height=\"100%\"\n                    onLoad={editor=>{\n                      editor.getSession().setUseWrapMode(true);\n                    }}\n                    setOptions={{\n                      enableBasicAutocompletion: true,\n                      enableLiveAutocompletion: true,\n                      showPrintMargin: false,\n                      enableSnippets: true,\n                      behavioursEnabled: false,\n                      showLineNumbers: true,\n                      tabSize: 2\n                    }}\n                  />\n                </div>\n                <button className=\"button is-success\" onClick={this.handleSave}>\n                  Save\n                </button>\n              </div>\n              }\n            </div>\n          )\n        }\n      }\n                    \n      SortableItem = ReactSortableElement(SortableItem);\n           \n      class SortableList extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        componentDidMount(){\n          if(this.props.initEditComponent){\n            this.props.initEditComponent(this);\n          }\n        }\n        \n        render(){\n          return (\n            <div>\n              {this.props.items.map((value, index) => (\n                <SortableItem key={`item-${index}`} index={index} value={value} />\n              ))}\n            </div>\n          );\n        }\n      }\n      \n      SortableList = ReactSortableContainer(SortableList); //({items}) => {\n      \n      // SortableList = universe.sharedComponents.withEditableNodeInfo(SortableList, {\n      //   editNodePath: 'app_toolbox/platform_browser/react_components/DefaultLayout',\n      //   editNodeId: '5af76ca59c4742002112b884'\n      // });   \n      \n      \n      console.log('Sortable components ok');\n\n      class MatchComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          \n          let matchNode = this.props.matchNode;\n          console.log('matchNode:', matchNode);\n          \n          return (\n            <div>\n              {(matchNode.data.position || 0) + 1}. \"{\n                matchNode.data.plain\n              }\"\n            </div>\n          )\n          \n        }\n      }\n      \n            // <div className=\"field choose-preparse-code has-addons\">\n            //   <div className=\"control is-expanded\">\n            //     <Select\n            //       placeholder=\"Pre-parse Match Code (determine whether to run, optionally adds Nodes)\"\n            //       value={this.state.currentSelectedPreParseCodeKey}\n            //       onChange={this.handleChangeSelectPreParseCode}\n            //       options={possiblePreParseCode}\n            //     />\n            //   </div>\n            //   {\n            //     !this.state.currentSelectedPreParseCodeKey ? '':\n            //     <div className=\"control\">\n            //       <a className=\"button is-default\" onClick={e=>this.handleRedirectToEditNode(this.state.currentSelectedPreParseCodeNode)}>\n            //         Edit\n            //       </a>\n            //     </div>\n            //   }\n            //   <div className=\"control\">\n            //     <a className=\"button is-default\" onClick={this.handleNewParseScenarioCode}>\n            //       New\n            //     </a>\n            //   </div>\n            \n            // </div>\n      \n      let ErrorComponent = (name) => {\n        return class ErrorComponent extends React.Component {\n          constructor(props){\n            super(props);\n            this.state = {}\n          }\n          \n          render(){\n            return (\n              <div>\n                ErrorLoading: {name || 'unknown'}\n              </div>\n            )\n          }\n        }\n      }\n    \n      class OutputErrorCatcherComponent extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {}\n        }\n        \n        componentDidCatch(error, info) {\n          // Display fallback UI\n          this.setState({ hasError: true });\n          // You can also log the error to an error reporting service\n          console.error('MainSituationListComponent OutputErrorCatcherComponent componentDidCatch:', error, info);\n        }\n        \n        render(){\n          if(this.state.hasError){\n            return (\n            <div>\n              OutputErrorCatcher\n              <br />\n              <pre><code>[TODO, error output]</code></pre>\n            </div>\n            )\n          }\n          \n          // normal\n          return this.props.children;\n        }\n      }\n      \n      class mycomponent extends React.Component {\n        constructor(props){\n          super(props);\n          \n          let searchIdentity;\n          try {\n            searchIdentity = props.state.OwnerSecondExternalIdentityNode.data.identity;\n          }catch(err){\n            console.error('Missing props.state.OwnerSecondExternalIdentityNode.data.identity', err);\n          }\n          \n          this.state = {\n            SituationMatchActionNodes: [],\n            PossibleMatchNodes: [],\n            PossibleActionNodes: [],\n            selectedSituationMatchActionNode: null, // when selected\n            groups: [], \n            allExternalConnections: [], \n            searchIdentity,\n            filterText: '',\n            postText: '',\n            postDescription: '',\n            postGroupNodeId: '', \n            isPosting: false,\n            tabsSituationMatchActionMainSelected: 'matches',\n            sharedNodeTypes: [\n              'code_package',\n              'situation_package'\n            ],\n            selectedSharedNodeType: 'code_package'\n          }\n        }\n        \n        componentDidMount(){\n          \n          console.log('Loaded MainSituationListComponent');\n          \n          if(this.props.initEditComponent){\n            this.props.initEditComponent(this);\n          }\n            \n          this.startup();\n            \n        }\n        \n        @autobind\n        async startup(){\n          // this.fetchGroups();\n          // this.fetchExternalConnections();\n          \n          // this.fetchFromRemoteForIdentity(this.props);\n          this.fetchGroups();\n          this.fetchExternalConnections();\n          this.fetchMine();\n          \n          this.fetchPossibleMatches();\n          this.fetchPossibleActions();\n          \n        }\n        \n        @autobind\n        fetchGroups(){\n          \n          return new Promise(async (resolve,reject)=>{\n            \n            this.setState({\n              fetchingGroups: true\n            });\n            \n            let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n              type: 'standard_capability_action:0.0.1:local:298j291bs',\n              data: {\n                action: 'send',\n                options: {\n                  ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                  RequestNode: {\n                    type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                    data: {\n                      actions: [\n                        {\n                          matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                          dataForAction: {\n                            type: 'string:...',\n                            data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                          }\n                        },\n                        {\n                          matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                          dataForAction: {\n                            type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                            data: {\n                              dataFilter: {\n                                nodeId: null, // root-level (not inside a shared node) \n                                'type' : {\n                                  $like: 'group_for_sharing:'\n                                }\n                              },\n                              matchFunctionNode: null,\n                              matchFunctionNode_OLD: {\n                                // query here!\n                                // action_pointer:0.0.1:local:238972ncr\n                                type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                data: {\n                                  code: `(()=>{\n                                    // Action \n                                    // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                    \n                                    let inputNode = INPUT.data.inputNode;\n                                    \n                                    if(inputNode.nodeId){\n                                      return false;\n                                    }\n                                    \n                                    if(inputNode.type.split(':')[0] != 'group_for_sharing'){\n                                      return false;\n                                    }\n                                    \n                                    return inputNode;\n                                    \n                                  })()`\n                                }\n                              },\n                              // expected/allowed schemas for return \n                              // outputSchemas: [\n                              //   'query_result:0.0.1:local:32490usfj23o23f',\n                              //   'internal_error_output:0.0.1:local:32948x2u3cno2c'\n                              // ]\n                            }\n                          }\n                        }\n                      ]\n                      \n                    }\n                  }\n                }\n              }\n            });\n            \n            // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n            let nodes = response.data.actionResponses[1].data;\n            \n            let postGroupNodeId = this.state.postGroupNodeId;\n            if(!postGroupNodeId){\n              postGroupNodeId = nodes.find(node=>{\n                return node.data.name == 'Private';\n              });\n              if(postGroupNodeId){\n                postGroupNodeId = postGroupNodeId._id;\n              }\n            }\n            \n            this.setState({\n              groups: nodes,\n              postGroupNodeId,\n              fetchingGroups: false\n            }, resolve);\n            \n          });\n          \n        }\n        \n        @autobind\n        fetchExternalConnections(){\n          \n          return new Promise(async (resolve,reject)=>{\n            \n            this.setState({\n              fetchingConnections: true\n            });\n            \n            let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n              type: 'standard_capability_action:0.0.1:local:298j291bs',\n              data: {\n                action: 'send',\n                options: {\n                  ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                  RequestNode: {\n                    type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                    data: {\n                      actions: [\n                        {\n                          matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                          dataForAction: {\n                            type: 'string:...',\n                            data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                          }\n                        },\n                        {\n                          matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                          dataForAction: {\n                            type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                            data: {\n                              dataFilter: {\n                                nodeId: null, // root-level (not inside a shared node) \n                                'type' : {\n                                  $like: 'external_identity:'\n                                }\n                              },\n                              matchFunctionNode: null,\n                              matchFunctionNode_OLD: {\n                                // query here!\n                                // action_pointer:0.0.1:local:238972ncr\n                                type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                data: {\n                                  code: `(()=>{\n                                    // Action \n                                    // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                    \n                                    let inputNode = INPUT.data.inputNode;\n                                    \n                                    if(inputNode.nodeId){\n                                      return false;\n                                    }\n                                    \n                                    if(inputNode.type.split(':')[0] != 'external_identity'){\n                                      return false;\n                                    }\n                                    \n                                    return inputNode;\n                                    \n                                  })()`\n                                }\n                              },\n                              // expected/allowed schemas for return \n                              // outputSchemas: [\n                              //   'query_result:0.0.1:local:32490usfj23o23f',\n                              //   'internal_error_output:0.0.1:local:32948x2u3cno2c'\n                              // ]\n                            }\n                          }\n                        }\n                      ]\n                      \n                    }\n                  }\n                }\n              }\n            });\n            \n            // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n            console.log('fetchExternalConnections Response:', response);\n            \n            let nodes = response.data.actionResponses[1].data;\n            \n            this.setState({\n              allExternalConnections: nodes,\n              fetchingConnections: false\n            }, this.updateConnectionGroups);\n            \n            resolve(nodes);\n            \n            \n          });\n          \n        }\n        \n        @autobind\n        fetchSelected(){\n          // fetch Mine or Remote depending on selected from select \n          \n          if(this.props.state.OwnerSecondExternalIdentityNode.data.identity == this.state.searchIdentity){\n            this.fetchMine();\n          } else {\n            this.fetchFromRemoteForIdentity(); \n          }\n          \n        }\n        \n        @autobind\n        fetchMine(){\n          // shared_node\n          // \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n              \n              this.setState({\n                fetchingMine: true\n              })\n              \n              // Get my identity \n              // - should use \"signer\" instead? \n              // - or just look for ones where signer=author \n              let author = this.props.state.OwnerSecondExternalIdentityNode.data.identity; // \"idtest:nick\" or \"internal:main\" ? \n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          \n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                      \n                          // Part 1/3\n                          // Fetch MY threads (where I am the author) \n                          // - of a \"post:Qmfdlsj\" type \n                          // - use the returned thread_ref to find ALL the related (by me or not) Posts (and other data too, I suppose) \n                          {\n                            matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                            dataForAction: {\n                              type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              data: {\n                                dataFilter: {\n                                  nodeId: null, // root-level (not inside a shared node) \n                                  'type' : {\n                                    $like: 'situation_match_action:'\n                                  }\n                                },\n                                matchFunctionNode: null\n                              }\n                            }\n                          }\n                          \n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              let nodes = response.data.actionResponses[1].data;\n              \n              // Create trees from nodes (in_reply_to) \n              // - get all of my unique Posts \n              let SituationMatchActionNodes = nodes;\n              \n              \n              console.log('SituationMatchActionNodes', SituationMatchActionNodes);\n              \n              // let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                SituationMatchActionNodes,\n                fetchingMine: false\n              })\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              this.setState({\n                fetchingMine: false\n              })\n              \n            }\n            \n          });\n          \n        }\n        \n        @autobind\n        fetchFromRemoteForIdentity(props){\n          // fetching data from a remote (syndicated-to) Second \n          // - data for a Single person's thread \n          \n          this.setState({\n            fetchingRemote: true\n          });\n          \n          props = props || this.props;\n          \n          console.log('fetchFromRemoteForIdentity.New Props', props);\n          console.log('this.props.state.OwnerSecondExternalIdentityNode', this.props.state.OwnerSecondExternalIdentityNode);\n          \n          let {\n            viewingIdentity,\n            searchIdentity\n          } = this.state;\n          \n          let viewIdentity = viewingIdentity;\n          \n          console.log('viewingIdentity',viewingIdentity, searchIdentity);\n          \n          // \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n              \n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          \n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                          \n                          {\n                            matchActionType: 'remote_run_action_sequence_authorized:Qm329f83289hsf',\n                            dataForAction: {\n                              type: 'remote_action_sequence_input:Qmf8329j29388923h8f22f',\n                              data: {\n                                // who to search (by identity, token) \n                                // action_sequence array \n                                \n                                identity: searchIdentity,\n                                // internalId: ExternalIdentityNode._id,\n                                // publicKey: ExternalIdentityNode.data.publicKey,\n                                \n                                actions: [\n                                  \n                                  // identify_via_token is added automatically to the beginning of the sequence\n                                  // {\n                                  //   matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                                  //   dataForAction: {\n                                  //     type: 'string:...',\n                                  //     data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                                  //   }\n                                  // },\n                                  {\n                                    matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                                    dataForAction: {\n                                      type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                                      data: {\n                                        dataFilter: {\n                                          nodeId: null, // root-level (not inside a shared node) \n                                          'type' : {\n                                            $like: 'situation_match_action:'\n                                          }\n                                        },\n                                        matchFunctionNode: null\n                                      }\n                                    }\n                                  }\n                                ]\n                                \n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              console.log('FullExternalResponse', response);\n              \n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              let nodes = response.data.actionResponses[1].data.actionResponses[3].data;\n              \n              console.log('Posts:', nodes.length, nodes);\n              \n              // Create trees from nodes (in_reply_to) \n              // - get all of my unique Posts \n              let SituationMatchActionNodes = nodes; \n              \n              this.setState({\n                SituationMatchActionNodes,\n                // fetchingMine: false\n              })\n              \n              \n            } catch(err){\n              console.error('Failed getting local nodes', err);\n            }\n            \n              \n            this.setState({\n              fetchingRemote: false\n            });\n            \n          \n          });\n          \n        }\n        \n        @autobind\n        fetchPossibleMatches(){\n          // get all posibilities for \"situation_match_builder\" nodes \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n              \n              this.setState({\n                fetchingMatches: true\n              })\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          \n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                      \n                          {\n                            matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                            dataForAction: {\n                              type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              data: {\n                                dataFilter: {\n                                  'parent.type' : {\n                                    $like: 'situation_match_builder:'\n                                  }\n                                },\n                                matchFunctionNode: null\n                              }\n                            }\n                          }\n                          \n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              let nodes = response.data.actionResponses[1].data;\n              \n              // Create trees from nodes (in_reply_to) \n              // - get all of my unique Posts \n              let PossibleMatchNodes = nodes;\n              \n              \n              console.log('PossibleMatchNodes', PossibleMatchNodes);\n              \n              // let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                PossibleMatchNodes\n              })\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n            }\n          \n            this.setState({\n              fetchingMatches: false\n            })\n            \n          });\n          \n        }\n        \n        @autobind\n        fetchPossibleActions(){\n          // get all posibilities for \"situation_match_builder\" nodes \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n              \n              this.setState({\n                fetchingActions: true\n              })\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          \n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                      \n                          {\n                            matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                            dataForAction: {\n                              type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              data: {\n                                dataFilter: {\n                                  'parent.type' : {\n                                    $like: 'situation_action_builder:'\n                                  }\n                                },\n                                matchFunctionNode: null\n                              }\n                            }\n                          }\n                          \n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              let nodes = response.data.actionResponses[1].data;\n              \n              // Create trees from nodes (in_reply_to) \n              // - get all of my unique Posts \n              let PossibleActionNodes = nodes;\n              \n              \n              console.log('PossibleActionNodes', PossibleActionNodes);\n              \n              // let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                PossibleActionNodes\n              })\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n            }\n            \n            this.setState({\n              fetchingActions: false\n            })\n            \n          });\n          \n        }\n        \n        @autobind\n        handleViewPackage(situationMatchActionNode){\n          // View a Code Package \n          console.log('situationMatchActionNode', situationMatchActionNode);\n          \n          this.setState({\n            tabsSituationMatchActionMainSelected: 'matches',\n            selectedSituationMatchActionNode: situationMatchActionNode,\n            // situationMatchActionOutputNode: null // kill previous output result\n          });\n          \n        }\n        \n        @autobind\n        handleEditPackage(situationMatchActionNode){\n          // View a Code Package \n          console.log('situationMatchActionNode to edit', situationMatchActionNode);\n          \n          this.props.setState({\n            situationMatchActionNode,\n          }, ()=>{\n            this.props.history.push('/node');\n          });\n          \n        }\n        \n        @autobind\n        async handleCreatePost(){\n          \n          let text = this.state.postText;\n          if(!text){\n            return false;\n          }\n          \n          let title = this.state.postTitle;\n          if(!title){\n            return false;\n          }\n          \n          let description = this.state.postDescription || '';\n          \n          let postGroupNodeId = this.state.postGroupNodeId;\n          if(!postGroupNodeId){\n            WINDOW.alert('Group required');\n            return false;\n          }\n          \n          let groupNode = this.state.groups.find(n=>{\n            return n._id == postGroupNodeId;\n          });\n          \n          console.log('State:', this.state);\n          \n          let sharedNode = {\n            type: 'code_package:Qmf3289h228fh',\n            data: {\n              // in_reply_to: null,\n              // thread_ref: universe.uuidv4(),\n              // message: text,\n              info: {\n                type: 'package_info:Qmsdlfkjsd',\n                data: {\n                  title,\n                  description,\n                  author: this.props.state.OwnerSecondExternalIdentityNode.data.identity, // \"idtest:nick\"\n                }\n              },\n              author: this.props.state.OwnerSecondExternalIdentityNode.data.identity, // \"idtest:nick\"\n              createdAt: Date.now(), // utc milliseconds since epoch \n              //visibility: 'public' // TODO: give simple direction on how to spread this data, if allowed \n              // usageLicense: \"Qmsdfljfl...\" // provide a usage license with your created content? \n              // TODO: verified/signed timestamp for this message (3rd party),\n              nodes: [{\n                type: 'code:0.0.1:local:32498h32f2',\n                data: {\n                  code: text\n                }\n              }]\n            }\n          }\n          \n          // should be OK to contain a code template \n          let permissionsNode = {\n            type: 'syndication_permissions:Qmsdfkjsl2fj9vxc',\n            data: {\n              rules: [{\n                type: 'allow_group:Qmsfkdljodsnkv',\n                data: {\n                  groupKey: groupNode.data.key\n                }\n              }]\n            }\n          };\n          \n          let syndicateToNode = {}; // done automatically, but could also provide a \"specifically syndicate this data somewhere\" node ? \n          \n          let saveSharedNode = await this.createNodeOnSecond(sharedNode, permissionsNode, syndicateToNode);\n          \n          console.log('saveSharedNode',saveSharedNode);\n          \n          // // refetch \n          // this.fetchMine();\n          \n          \n        }\n        \n        @autobind\n        createNodeOnSecond(nodeToSave){\n          return new Promise(async (resolve, reject) => {\n            \n            console.log('NewNode:', nodeToSave);\n                \n            // Make request to save Node on remote \n            try {\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          \n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                          \n                          {\n                            matchActionType: 'create_node:Qmf3892j39f8h9babb',\n                            dataForAction: {\n                              type: 'create_node_data:Qmdslkfj29f0j82',\n                              data: {\n                                optionsNode: {\n                                  type: 'options_generic:0.0.1:local:289f3j29832',\n                                  data: {}\n                                },\n                                dataNode: nodeToSave\n                              }\n                            }\n                          }\n                        ]\n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('create_node response:', response);\n              \n              // get the created node \n              let savedNode = response.data.actionResponses[1];\n              \n              // console.log('Saved Node:', savedNode);\n            \n              try {\n                universe.EE.emit('nodes-modified', '');\n              }catch(err){\n                console.error(err);\n              }\n              \n              return resolve(savedNode);\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            } catch(err){\n              console.error('Failed creating new node', err);\n              \n              // alert('Failed');\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        makeSaveRequest(nodeToSave, opts, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            this.setState({\n              saving: true\n            })\n            \n            opts = opts || {};\n            \n            // Make request to save Node on remote \n            try {\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                          {\n                            matchActionType: 'update_node:0.0.2:local:392821982y3',\n                            dataForAction: {\n                              type: 'update_node_data:0.0.2:local:123445',\n                              data: {\n                                optionsNode: {\n                                  type: 'options_generic:0.0.1:local:289f3j29832',\n                                  data: opts || {}\n                                },\n                                dataNode: nodeToSave\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('Update response:', response);\n              \n              if(skipEvent !== true){\n                try {\n                  universe.EE.emit('nodes-modified', '');\n                }catch(err){\n                  console.error(err);\n                }\n              }\n              \n              this.setState({\n                saving: false\n              })\n              \n              return resolve({\n                type: 'node:...',\n                data: response.data.actionResponses[1]\n              });\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              alert('Failed');\n              \n              this.setState({\n                saving: false\n              })\n              \n              return reject();\n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        handleSituationsCompile(){\n          \n          return new Promise(async (resolve, reject) => {\n            \n            this.setState({\n              isCompiling: true\n            })\n            \n            try {\n              \n              let responseNode = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                          {\n                            matchActionType: 'situation_compile_action:Qmf892h',\n                            dataForAction: {\n                              type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              data: {}\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              \n              this.setState({\n                isCompiling: false\n              })\n              \n              return resolve(responseNode);\n              \n            } catch(err){\n              console.error('Failed situations compile');\n              \n              this.setState({\n                isCompiling: false\n              })\n              \n              return reject();\n              \n            }\n            \n          })\n          \n        }\n        \n        @autobind\n        handleRunSituation(runKey){\n          \n          // run a specific situation action \n          \n          return new Promise(async (resolve, reject) => {\n            \n            this.setState({\n              saving: true\n            })\n            \n            opts = opts || {};\n            \n            // Make request to save Node on remote \n            try {\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                          {\n                            matchActionType: 'situation_input_action:Qmsdf32oj',\n                            dataForAction: {\n                              type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              data: {\n                                type: 'list_of_context_nodes:Qdmsfl23f',\n                                // update with nodes for context!\n                                data: [\n                                  {\n                                    type: 'input_type:Qmdsklf', \n                                    data: {\n                                      name: runKey\n                                    }\n                                  }\n                                ]\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('Update response:', response);\n              \n              if(skipEvent !== true){\n                try {\n                  universe.EE.emit('nodes-modified', '');\n                }catch(err){\n                  console.error(err);\n                }\n              }\n              \n              this.setState({\n                saving: false\n              })\n              \n              return resolve({\n                type: 'node:...',\n                data: response.data.actionResponses[1]\n              });\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              alert('Failed');\n              \n              this.setState({\n                saving: false\n              })\n              \n              return reject();\n              \n            }\n            \n          })\n          \n        }\n        \n        @autobind\n        handleUpdatePost(){\n        }\n        \n        @autobind\n        handleRemovePost(){\n        }\n        \n        @autobind\n        handleUpdatePostTitle(e){\n          this.setState({\n            postTitle: e.target.value\n          });\n        }\n        \n        @autobind\n        handleUpdatePostText(e){\n          this.setState({\n            postText: e.target.value\n          });\n        }\n        \n        @autobind\n        handleUpdatePostDescription(e){\n          this.setState({\n            postDescription: e.target.value\n          });\n        }\n        \n        @autobind\n        handleUpdateSyndicationSearchTarget(e){\n          // TODO: add multiple groups, identities, deny rules, etc. ! \n          this.setState({\n            searchIdentity: e.target.value\n          });\n        }\n        \n        @autobind\n        handleUpdateViewIdentityType(e){\n          // TODO: add multiple groups, identities, deny rules, etc. ! \n          this.setState({\n            viewIdentityType: e.target.value\n          });\n        }\n        \n        \n        @autobind\n        handleUpdatePostGroup(e){\n          // TODO: add multiple groups, identities, deny rules, etc. ! \n          this.setState({\n            postGroupNodeId: e.target.value\n          });\n        }\n        \n        @autobind\n        handleUpdateSharedPackageType(e){\n          this.setState({\n            selectedSharedNodeType: e.target.value\n          });\n        }\n        \n        @autobind\n        async handleCreateMatchBuilderNode(){\n          \n          // Add a node to the match builder \n          console.log('handleCreateMatchBuilderNode');\n          let builder = universe.lodash.query(this.state.selectedSituationMatchActionNode.nodes,{\n            type: {\n              $like: 'situation_match_builder:'\n            }\n          });\n          if(!builder.length){\n            // no matches!\n            return console.error('Missing situation_match_builder');\n          }\n          builder = builder[0];\n          \n          console.log('builder', builder);\n          \n          let plain = WINDOW.prompt('plain text:');\n          if(!plain){\n            return false;\n          }\n          \n          let node = {\n            nodeId: builder._id,\n            name: universe.uuidv4(),\n            type: 'match_temp:Qmsldfj',\n            data: {\n              plain,\n              query: \"{}\",\n              position: builder.nodes.length\n            }\n          }\n          \n          console.log('Creating:', node);\n          \n          let createNodeResponse = await this.createNodeOnSecond(node);\n          \n          console.log('createNodeResponse',createNodeResponse);\n          \n          // // refetch \n          // this.fetchMine();\n          \n          \n        }\n        \n        @autobind\n        async handleCompileMatch(){\n          // compile match_builder nodes into single query for matching \n          // - TODO: handle server-side, with ML \n          \n          // Add a node to the match builder \n          console.log('handleCompileMatch');\n          let existingMatchNode = universe.lodash.query(this.state.selectedSituationMatchActionNode.nodes,{\n            type: {\n              $like: 'situation_match:'\n            }\n          });\n          if(!existingMatchNode.length){\n            // no matches!\n            return console.error('Missing existing situation_match');\n          }\n          existingMatchNode = existingMatchNode[0];\n          \n          \n          let builder = universe.lodash.query(this.state.selectedSituationMatchActionNode.nodes,{\n            type: {\n              $like: 'situation_match_builder:'\n            }\n          });\n          if(!builder.length){\n            // no matches!\n            return console.error('Missing situation_match_builder');\n          }\n          builder = builder[0];\n          \n          let builderNodes = builder.nodes.sort((a,b)=>{\n            return (a.data.position - b.data.position)\n          });\n          \n          let queries = builderNodes.map(builderNode=>{\n            return JSON.parse(builderNode.data.query);\n          });\n          \n          existingMatchNode.data.query = JSON.stringify({\n            $and: queries\n          })\n          \n          console.log('Saving existingMatchNode', existingMatchNode);\n          \n          await this.makeSaveRequest(existingMatchNode);\n          \n          \n        }\n        \n        @autobind\n        async handleCreateActionBuilderNode(){\n          \n          // Add a node to the match builder \n          console.log('handleCreateActionBuilderNode');\n          let builder = universe.lodash.query(this.state.selectedSituationMatchActionNode.nodes,{\n            type: {\n              $like: 'situation_action_builder:'\n            }\n          });\n          if(!builder.length){\n            // no matches!\n            return console.error('Missing situation_action_builder');\n          }\n          builder = builder[0];\n          \n          console.log('builder', builder);\n          \n          let plain = WINDOW.prompt('plain text:');\n          if(!plain){\n            return false;\n          }\n          \n          let node = {\n            nodeId: builder._id,\n            name: universe.uuidv4(),\n            type: 'action_temp:Qmsldfj',\n            data: {\n              plain,\n              code: `if(1==1){console.log(return false)}`,\n              position: builder.nodes.length\n            }\n          }\n          \n          console.log('Creating:', node);\n          \n          let createNodeResponse = await this.createNodeOnSecond(node);\n          \n          console.log('createNodeResponse',createNodeResponse);\n          \n          // // refetch \n          // this.fetchMine();\n          \n          \n        }\n        \n        @autobind\n        async handleCompileAction(){\n          // compile action_builder nodes into single code action \n          // - TODO: handle server-side, with ML \n          \n          // Add a node to the Action builder \n          console.log('handleCompileAction');\n          let existingActionNode = universe.lodash.query(this.state.selectedSituationMatchActionNode.nodes,{\n            type: {\n              $like: 'situation_action:'\n            }\n          });\n          if(!existingActionNode.length){\n            return console.error('Missing existing situation_action');\n          }\n          existingActionNode = existingActionNode[0];\n          \n          \n          let existingActionCodeNode = universe.lodash.query(existingActionNode.nodes,{\n            type: {\n              $like: 'code:'\n            }\n          });\n          if(!existingActionCodeNode.length){\n            return console.error('Missing existing situation_action code node for updating');\n          }\n          existingActionCodeNode = existingActionCodeNode[0];\n          \n          \n          let builder = universe.lodash.query(this.state.selectedSituationMatchActionNode.nodes,{\n            type: {\n              $like: 'situation_action_builder:'\n            }\n          });\n          if(!builder.length){\n            // no matches!\n            return console.error('Missing situation_action_builder');\n          }\n          builder = builder[0];\n          \n          let builderNodes = builder.nodes.sort((a,b)=>{\n            return (a.data.position - b.data.position)\n          });\n          \n          let codeFragments = builderNodes.map(builderNode=>{\n            return builderNode.data.code;\n          });\n          \n          // TODO: build a static version of this dynamic-ly built action \n          // - want to make it easy to build actions lego-like (easier for people, easier for ML) \n          \n          // INPUT is the context (search: \"nodeStateArrayForMatching\")\n          // - state of the world \n          // - pass-thru input nodes \n          // - etc. \n          \n          // Add to context request \n          // - \n          \n          // OUTPUT \n          // - \"what I'm going to do\" \n          \n          // \"continue\" Situation handling \n          // - handle new situation in Chain/Tree \n          \n          // For this Default Common First node: \n          // - add a \"processed_default_common\" flag \n          // - start another Situation, with same context nodes \n          \n          let code = `\n          (()=>{\n            return new Promise(async (resolve,reject)=>{\n              ${codeFragments.join(\"\\n\\n\")}\n            })\n          })()\n          `;\n          existingActionCodeNode.data.code = code; // .join('\\n\\n');\n          \n          console.log('Saving existingActionNode', existingActionCodeNode);\n          \n          await this.makeSaveRequest(existingActionCodeNode);\n          \n          \n        }\n        \n        @autobind\n        renderResults(){\n          // console.log('Rendering MainHomeComponent.renderSnippets');\n          if(!this.state.SituationMatchActionNodes.length && this.state.fetchingMine){\n            return (\n              <div>\n                <i>Fetching situations</i>\n              </div>\n            )  \n          }\n          \n          return (\n            <table className=\"table is-narrow\" style={{width: '100%'}}>\n              <thead>\n                <th>Name</th>\n                <th></th>\n                <th>Created</th>\n              </thead>\n              <tbody>\n                {\n                  this.state.SituationMatchActionNodes.filter(situationMatchActionNode=>{\n                    // filter text\n                    return (situationMatchActionNode.data.name || situationMatchActionNode.data.info.data.name).toLowerCase().indexOf(this.state.filterText.toLowerCase()) > -1\n                  }).map((situationMatchActionNode,idx)=>{\n                    \n                    return (\n                      <tr key={situationMatchActionNode._id}>\n                        <td>\n                          <a onClick={()=>this.handleViewPackage(situationMatchActionNode)}>\n                            \"{\n                              situationMatchActionNode.data.name || '--Missing Name--'\n                            }\"\n                          </a>\n                        </td>\n                        <td>\n                          {\n                            situationMatchActionNode.data.enabled ? \n                              <span className=\"\">\n                                Enabled\n                              </span>\n                            :\n                              <span className=\"has-text-danger\">\n                                Disabled\n                              </span>\n                          }\n                        </td>\n                        <td>\n                          <small>{situationMatchActionNode.createdAt}</small>\n                        </td>\n                      </tr>\n                    )\n                  }) \n                }\n              </tbody>\n            </table>\n          )\n        }\n        \n        @autobind\n        onSortStartMatches(){\n          console.log('Sort started!');\n        }\n        \n        @autobind\n        onSortEndMatches(oldIndex, newIndex){\n          console.log('ended sort');\n          \n          // this.setState({\n          //   items: ReactSortableArrayMove(this.state.items, oldIndex, newIndex),\n          // });\n          \n        }\n        \n        @autobind\n        renderMatches(selectedSituationMatchActionNode){\n          let builder = universe.lodash.query(selectedSituationMatchActionNode.nodes,{\n            type: {\n              $like: 'situation_match_builder:'\n            }\n          });\n          if(!builder.length){\n            // no matches!\n            return (<div>No Matches</div>);\n          }\n          builder = builder[0];\n          \n          let builderNodes = builder.nodes.sort((a,b)=>{\n            return (a.data.position - b.data.position)\n          });\n          \n          \n          \n          return (\n            <div>\n              <SortableList \n                items={builderNodes} \n                pressDelay={200}\n                onSortStart={this.onSortStartMatches} \n                onSortEnd={this.onSortEndMatches} \n              />\n              \n              {/*\n                builderNodes.map(matchNode=>(\n                  <MatchComponent\n                    key={matchNode._id}\n                    matchNode={matchNode}\n                    possibleMatches={this.state.possibleMatches}\n                    onAction={this.handleMatchAction}\n                  />\n                ))\n              */}\n              \n              <br />\n              <div>\n                <button className=\"button\" onClick={this.handleCreateMatchBuilderNode}>\n                  New\n                </button>\n                \n              </div>\n            </div>\n          )\n        }\n        \n        @autobind\n        renderActions(selectedSituationMatchActionNode){\n          let builder = universe.lodash.query(selectedSituationMatchActionNode.nodes,{\n            type: {\n              $like: 'situation_action_builder:'\n            }\n          });\n          if(!builder.length){\n            // no matches!\n            return (<div>No Matches</div>);\n          }\n          builder = builder[0];\n          \n          let builderNodes = builder.nodes.sort((a,b)=>{\n            return (a.data.position - b.data.position)\n          });\n          \n          return (\n            <div>\n              {\n                builderNodes.map(matchNode=>(\n                  <div key={matchNode._id}>\n                    {(matchNode.data.position || 0) + 1}. \"{\n                      matchNode.data.plain\n                    }\"\n                  </div>\n                ))\n              }\n              \n              <br />\n              <div>\n                <button className=\"button\" onClick={this.handleCreateActionBuilderNode}>\n                  New\n                </button>\n                &nbsp;\n                \n                <button className=\"button\" onClick={this.handleResetRules}>\n                  Reset Rules\n                </button>\n                <button className=\"button\" onClick={this.handleProcessRules}>\n                  Process Rules\n                </button>\n                \n                <br />\n                {\n                  this.state.PossibleActionNodes.map(action=>(\n                    <div key={action._id}>\n                      \"{action.data.plain}\"\n                    </div>\n                  ))\n                }\n                \n              </div>\n            </div>\n          )\n        }\n        \n        @autobind\n        renderSituationMatchAction(){\n          let situationMatchActionNode = this.state.selectedSituationMatchActionNode;\n          if(!situationMatchActionNode){\n            return (\n              <div>\n                <br /><br /><br /><br />\n                <i>none selected</i>\n              </div>\n            )\n          }\n          \n          let tabsSituationMatchActionMain = [\n            ['matches','Matches'],\n            ['actions', 'Actions'],\n            ['rules', 'Rules']\n          ];\n          \n          \n          return (\n            <div>\n              <br /><br /><br /><br />\n              <h2 className=\"title is-4\">\n                {\n                  situationMatchActionNode.data.name\n                }\n              </h2>\n              <h2 className=\"subtitle is-6\">\n                {\n                  situationMatchActionNode.data.description\n                }\n              </h2>\n              \n              <div className=\"tabs\">\n                <ul>\n                  {\n                    tabsSituationMatchActionMain.map(tab=>(\n                      <li key={tab[0]}\n                        onClick={e=>this.setState({tabsSituationMatchActionMainSelected:tab[0]})}\n                        className={(this.state.tabsSituationMatchActionMainSelected == tab[0]) ? 'is-active':''}\n                        ><a>{tab[1]}</a></li>\n                    ))\n                  }\n                </ul>\n              </div>\n              \n              {\n                this.state.tabsSituationMatchActionMainSelected != 'matches' ? '':\n                <div>\n                  {\n                    this.renderMatches(this.state.selectedSituationMatchActionNode)\n                  }\n                  {/*\n                  <div>\n                    <button className='button is-default'>\n                      Matches\n                    </button>\n                  </div>\n                  <hr />\n                  <pre><code></code></pre>*/}\n                </div>\n              }\n              \n              {\n                this.state.tabsSituationMatchActionMainSelected != 'actions' ? '':\n                <div>\n                  {\n                    this.renderActions(this.state.selectedSituationMatchActionNode)\n                  }\n                </div>\n              }\n              \n            </div>\n          )\n          \n        }\n        \n        render(){\n          // console.log('Rendering MainHomeComponent');\n          return (\n            <div className=\"container\" style={{marginTop:'0.75em'}} ref={r=>this.ref=r}>\n              <div className=\"columns\">\n                <div className=\"column is-6\">\n                \n                  <br />\n                  \n                  <div className=\"field has-addons\" style={{display:'none'}}>\n                    <div className=\"control\">\n                      <button className={\"button is-default\"} onClick={this.fetchMine}>\n                        Fetch Mine\n                      </button>\n                      <button className={\"button is-default\"} onClick={e=>this.fetchFromRemoteForIdentity(this.props)}>\n                        Fetch Remote/Syndicated\n                      </button>\n                    </div>\n                    {\n                      !this.state.fetchingRemote ? '':\n                      <div className=\"control\">\n                        <a className=\"button is-loading\">\n                          &nbsp;\n                        </a>\n                      </div>\n                    }\n                  </div>\n                  \n                  {/* Filter */}\n                  <div className=\"field is-grouped\">\n                  \n                    <div className=\"control is-expanded\">\n                      <input className=\"input\" value={this.state.filterText} onChange={e=>this.setState({filterText:e.target.value})} placeholder=\"Filter Situation\" />\n                    </div>\n            \n                    <div className=\"control\" style={{width:'25%'}}>\n                    \n                      <div className=\"select\">\n                        <select onChange={this.handleUpdateSyndicationSearchTarget} value={this.state.searchIdentity}>\n                          {\n                            this.state.allExternalConnections.filter(e=>{return e.data.identity}).map(externalIdentity=>(\n                              <option key={externalIdentity._id} value={externalIdentity.data.identity}>{externalIdentity.data.identity}</option>\n                            ))\n                          }\n                          {\n                            (!this.state.allExternalConnections.length && this.state.fetchingConnections) ?\n                            <option>Loading sources</option>\n                            :''\n                          }\n                        </select>\n                      </div>\n                      \n                    </div>\n                    \n                    <div className=\"control\">\n                      <button className={\"button is-info \" + (this.state.fetchingForSearch ? 'is-loading':'')} onClick={this.fetchSelected}>\n                        Find\n                      </button>\n                    </div>\n                    \n                    <div className=\"control\" style={{lineHeight:'34px'}}>\n                      |\n                    </div>\n                    \n                    <div className=\"control\">\n                      \n                      <button className=\"button is-info\">\n                        <span>New</span>\n                      </button>\n                      \n                    </div>\n                    \n                    <div className=\"control\">\n                      \n                      <button className=\"button\" onClick={this.handleSituationsCompile}>\n                        <span>Compile</span>\n                      </button>\n                      \n                    </div>\n                    \n                    <div className=\"control\">\n                      \n                      <div className=\"dropdown is-hoverable\">\n                        <div className=\"dropdown-trigger\">\n                          <button className=\"button\" aria-haspopup=\"true\" aria-controls=\"dropdown-menu3\">\n                            <span>Run</span>\n                            <span className=\"icon is-small\">\n                              <i className=\"fas fa-angle-down\" aria-hidden=\"true\"></i>\n                            </span>\n                          </button>\n                        </div>\n                        <div className=\"dropdown-menu\" id=\"dropdown-menu3\" role=\"menu\">\n                          <div className=\"dropdown-content\">\n                            <a href=\"#\" className=\"dropdown-item\" onClick={e=>this.handleRunSituation('button')}>\n                              Button\n                            </a>\n                            <a href=\"#\" className=\"dropdown-item\" onClick={e=>this.handleRunSituation('speaker_on')}>\n                              Sprinkler On\n                            </a>\n                            <a href=\"#\" className=\"dropdown-item\" onClick={e=>this.handleRunSituation('speaker_off')}>\n                              Sprinkler Off\n                            </a>\n                          </div>\n                        </div>\n                      </div>\n                      \n                    </div>\n                    \n                  </div>\n                  \n                  \n                  <hr />\n                  \n                  <br />\n                  \n                  <div>\n                    {\n                      this.renderResults()\n                    }\n                  </div>\n                  \n                </div>\n                \n                <div className=\"column is-6\">\n                  {\n                    this.renderSituationMatchAction()\n                  }\n                </div>\n                \n              </div>\n            </div>\n          )\n        }\n      }\n      \n      mycomponent = universe.ReactGlobalState(mycomponent);\n      mycomponent = universe.ReactHelpers(mycomponent);\n      mycomponent = universe.ReactRouterDomWithRouter(mycomponent);\n      \n      mycomponent = universe.sharedComponents.withEditableNodeInfo(mycomponent, {\n        localNode: SELF\n        // editNodePath: 'app_toolbox/platform_browser/react_components/MainSituationListComponent',\n        // editNodeId: '5b467072ee033c0024c008c9'\n      });   \n            \n      const styles = {\n        deleteIcon: {\n          position: 'absolute',\n          top: '0px',\n          right: '-24px',\n          cursor: 'pointer'\n        }\n      }\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: mycomponent\n      });\n      \n    }catch(err){\n      console.error(err);\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()",
    "internalId": "MainSituationListComponent"
  }
}