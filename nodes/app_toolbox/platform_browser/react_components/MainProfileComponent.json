{
  "type": "react_component:0.0.1:local:98912hd89",
  "name": "MainProfileComponent",
  "data": {
    "author": "-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCcuXovU+RZy85KMqLakYSH1mdV\nWdpEUtgcXUyGyU5hVeTO7BkV/kxeC2upcxOwNnrBOdsvHI3nrrILgt90/hCSHKzx\nhOFLREorGoKtSEHxI7/SnzzlWtV3gT/IP5GVHIyvuJBx3hCti0dH55DZG8iMGZ2y\ncGpV73Dez3hHmeBh6wIDAQAB\n-----END PUBLIC KEY-----",
    "version": "1",
    "key": "2d9f4110-3a07-4dc9-8425-971c1a4edb74",
    "code": "(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      const AceEditor = universe.AceEditor;\n      const ReactResizeDetector = universe.ReactResizeDetector;\n      const RecreateChildOnPropsChange = universe.RecreateChildOnPropsChange;\n      \n      const ReactMarkdown = universe.ReactMarkdown;\n      \n      class EmbeddedComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              embeddedComponenthere\n            </div>\n          )\n        }\n      }\n      \n      let ErrorComponent = (name) => {\n        return class ErrorComponent extends React.Component {\n          constructor(props){\n            super(props);\n          }\n          render(){\n            return (\n              <div>\n                ErrorLoading: {name || 'unknown'}\n              </div>\n            )\n          }\n        }\n      }\n      \n      class mycomponent extends React.Component {\n        constructor(props){\n          super(props);\n          \n          this.state = {\n            myProfiles: [],\n            // groups: [], // from parent\n            // allExternalConnections: [], // from parent\n            profileText: '',\n            profileGroupNodeId: '', \n            creatingProfile: false,\n          }\n        }\n        \n        componentDidMount(){\n          \n          console.log('Loaded MainProfileComponent');\n            \n          this.startup();\n            \n        }\n        \n        @autobind\n        async startup(){\n          // this.fetchGroups();\n          // this.fetchExternalConnections();\n          \n          this.fetchFromRemoteForIdentity(this.props);\n          \n        }\n        \n        @autobind\n        fetchFromRemoteForIdentity(props){\n          // fetching data from a remote (syndicated-to) Second \n          // - data for a Single person's thread \n          \n          this.setState({\n            fetchingRemote: true\n          });\n          \n          props = props || this.props;\n          \n          console.log('fetchFromRemoteForIdentity.New Props', props);\n          console.log('this.props.state.OwnerSecondExternalIdentityNode', this.props.state.OwnerSecondExternalIdentityNode);\n          \n          let {\n            viewingIdentity,\n            searchIdentity\n          } = props;\n          \n          let viewIdentity = viewingIdentity;\n          \n          console.log('viewingIdentity',viewingIdentity, searchIdentity);\n          \n          // \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n              \n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          \n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                          \n                          {\n                            matchActionType: 'remote_run_action_sequence_authorized:Qm329f83289hsf',\n                            dataForAction: {\n                              type: 'remote_action_sequence_input:Qmf8329j29388923h8f22f',\n                              data: {\n                                // who to search (by identity, token) \n                                // action_sequence array \n                                \n                                identity: searchIdentity,\n                                // internalId: ExternalIdentityNode._id,\n                                // publicKey: ExternalIdentityNode.data.publicKey,\n                                \n                                actions: [\n                                  \n                                  // identify_via_token is added automatically to the beginning of the sequence\n                                  // {\n                                  //   matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                                  //   dataForAction: {\n                                  //     type: 'string:...',\n                                  //     data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                                  //   }\n                                  // },\n                              \n                                  // Part 1/3\n                                  // Fetch MY threads (where I am the author) \n                                  // - of a \"profile:Qmfdlsj\" type \n                                  // - use the returned thread_ref to find ALL the related (by me or not) Profiles (and other data too, I suppose) \n                                  {\n                                    matchActionType: 'search_shared_data:Qmksdjhfwekjhdds24f',\n                                    dataForAction: {\n                                      // type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                                      type: 'shared_data_request:Qmsdfljsdj',\n                                      data: {\n                                        // filter on the ENTIRE shared_node (NOT just on the shared_node data) \n                                        dataFilter: {\n                                          'data.type' : {\n                                            $like: 'identity_profile:'\n                                          },\n                                          'data.signer': viewIdentity,\n                                          'data.data.author' : viewIdentity\n                                        },\n                                      }\n                                    }\n                                  },\n                                  \n                                  // TODO: reduce to only the titles, necessary info \n                                  \n                                  // TODO: clear results I dont care about (map->reduce...kill all the map results!) \n                                  \n                                ]\n                                \n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              console.log('FullExternalResponse', response);\n              \n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              let nodes = response.data.actionResponses[1].data.actionResponses[1].data;\n              \n              console.log('Identity Profiles:', nodes.length, nodes);\n              \n              // Create trees from nodes (in_reply_to) \n              // - get all of my unique Profiles \n              let myProfiles = universe.lodash.uniq(nodes.filter(node=>{\n                // filter \n                return node.data.data.author == viewIdentity;\n              }), node=>{\n                // uniq filter \n                return node.data._id; // unique id of source (identity:address) \n              }).sort((a,b)=>{\n                // newest at top \n                return a.data.data.createdAt < b.data.data.createdAt;\n              });\n              \n              \n              this.setState({\n                myProfiles,\n                // fetchingMine: false\n              })\n              \n              \n            } catch(err){\n              console.error('Failed getting local nodes', err);\n            }\n            \n              \n            this.setState({\n              fetchingRemote: false\n            });\n            \n          \n          });\n          \n        }\n        \n        @autobind\n        async handleCreateNode(){\n          \n          let avatar_url = WINDOW.prompt('avatar_url','');\n          if(!avatar_url){\n            return false;\n          }\n          \n          let name = WINDOW.prompt('Your name');\n          if(!name){\n            return false;\n          }\n          \n          \n          let bio = WINDOW.prompt('Your bio');\n          if(!bio){\n            return false;\n          }\n          \n          let profileGroupNodeId = this.state.profileGroupNodeId;\n          let groupNode = this.props.groups.find(n=>{\n            return n._id == profileGroupNodeId;\n          });\n          if(!groupNode){\n            WINDOW.alert('Group required');\n            return false;\n          }\n          \n          // console.log('State:', this.state);\n          \n          let sharedNode = {\n            type: 'identity_profile:Qm328fh239sfd',\n            data: {\n              avatar: avatar_url, // should be an avatar_node (so I can save the url/image myself) \n              name,\n              bio,\n              author: this.props.state.OwnerSecondExternalIdentityNode.data.identity, // \"idtest:nick\"\n              createdAt: Date.now(), // utc milliseconds since epoch,\n              updatedAt: Date.now()\n            }\n          }\n          \n          // should be OK to contain a code template \n          let permissionsNode = {\n            type: 'syndication_permissions:Qmsdfkjsl2fj9vxc',\n            data: {\n              rules: [{\n                type: 'allow_group:Qmsfkdljodsnkv',\n                data: {\n                  groupKey: groupNode.data.key\n                }\n              }]\n            }\n          };\n          \n          let syndicateToNode = {}; // done automatically, but could also provide a \"specifically syndicate this data somewhere\" node ? \n          \n          let saveSharedNode = await this.createNodeOnSecond(sharedNode, permissionsNode, syndicateToNode);\n          \n          console.log('saveSharedNode',saveSharedNode);\n          \n          // // refetch \n          // this.fetchMine();\n          \n          \n        }\n        \n        @autobind\n        createNodeOnSecond(sharedNode, permissionsNode, syndicateToNode){\n          return new Promise(async (resolve, reject) => {\n            \n            console.log('NewNode:', sharedNode);\n                \n            this.setState({\n              creatingProfile: true\n            });\n            \n            // Make request to save Node on remote \n            try {\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          // TODO: use identity token \n                          {\n                            matchActionType: 'create_and_syndicate:Qmwlekjfwl',\n                            dataForAction: {\n                              type: 'create_and_syndicate_data:Qmskfjwoesjf',\n                              data: {\n                                sharedNode, // should include author=Second \n                                permissionsNode, // who can access this, get syndicated also \n                                syndicateToNode // where to syndicate this sharedNode  \n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('create_and_syndicate response:', response);\n              \n              // get the created node \n              let savedNode = response.data.actionResponses[0];\n              \n              // console.log('Saved Node:', savedNode);\n            \n              try {\n                universe.EE.emit('nodes-modified', '');\n              }catch(err){\n                console.error(err);\n              }\n              \n              resolve(savedNode);\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              // alert('Failed');\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            }\n            \n            this.setState({\n              creatingProfile: false\n            });\n            \n          })\n        }\n        \n        @autobind\n        updateNodeOnSecond(sharedNode, permissionsNode, syndicateToNode){\n          return new Promise(async (resolve, reject) => {\n            \n            console.log('NewNode:', sharedNode);\n            \n            this.setState({\n              creatingProfile: true,\n              updatingProfile: true\n            });\n            \n            // Make request to update Node on remote \n            try {\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          // TODO: use identity token \n                          {\n                            matchActionType: 'update_and_syndicate:Qm3289fh239823',\n                            dataForAction: {\n                              type: 'update_and_syndicate_data:Qmfh178gvghva54',\n                              data: {\n                                sharedNode, // should include author=Second \n                                permissionsNode, // who can access this, get syndicated also \n                                syndicateToNode // where to syndicate this sharedNode  \n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('update_and_syndicate response:', response);\n              \n              // get the created node \n              let savedNode = response.data.actionResponses[0];\n              \n              // console.log('Saved Node:', savedNode);\n            \n              try {\n                universe.EE.emit('nodes-modified', '');\n              }catch(err){\n                console.error(err);\n              }\n              \n              resolve(savedNode);\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              // alert('Failed');\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            }\n            \n            this.setState({\n              creatingProfile: false,\n              updatingProfile: false\n            });\n            \n          })\n        }\n        \n        \n        @autobind\n        handleUpdateProfileGroup(e){\n          // TODO: add multiple groups, identities, deny rules, etc. ! \n          this.setState({\n            profileGroupNodeId: e.target.value\n          });\n        }\n        \n        @autobind\n        handleUpdateProfileText(e){\n          this.setState({\n            profileText: e.target.value\n          });\n        }\n        \n        @autobind\n        handleUpdateProfileTitle(e){\n          this.setState({\n            profileTitle: e.target.value\n          });\n        }\n        \n        @autobind\n        handleViewProfile(profileSharedNode){\n          this.setState({\n            profileNode: profileSharedNode\n          });\n        }\n        \n        @autobind\n        renderProfiles(){\n          // console.log('Render Profiles:',this.state.myProfiles);\n          return (\n            <table className=\"table is-narrow is-fullwidth\">\n              <thead>\n                <th>\n                  Name\n                </th>\n                <th>\n                  Updated\n                </th>\n              </thead>\n              <tbody>\n                {\n                  this.state.myProfiles.map((profile,idx)=>{\n                    return (\n                      <tr key={profile._id}>\n                        <td onClick={e=>this.handleViewProfile(profile)} style={{cursor:'pointer'}}>\n                          {\n                            profile.data.data.name\n                          }\n                        </td>\n                        <td>\n                          {universe.moment(profile.data.data.createdAt,'x').fromNow()}\n                        </td>\n                      </tr>\n                    )\n                  })\n                }\n              </tbody>\n            </table>\n          )\n        }\n        \n        @autobind\n        renderProfile(){\n          \n          if(!this.state.profileNode){\n            return '';\n          }\n          \n          let profile = this.state.profileNode;\n          \n          // return viewable markdown profile \n          let name = profile.data.data.name || '';\n          let bio = profile.data.data.bio || ''; // text expected, hashes, etc. converted? (TODO) \n          let avatar_url = profile.data.data.avatar; //`## Testing profile title `;\n          \n          return (\n            <div className=\"columns\">\n              <div className=\"column is-5\">\n              \n                <div className=\"card\">\n                  <div className=\"card-image\">\n                    <figure className=\"image is-4by3\">\n                      <img src={avatar_url} />\n                    </figure>\n                  </div>\n                  <div className=\"card-content\">\n                    <div className=\"media\">\n                      <div className=\"media-left\">\n                        <figure className=\"image is-48x48\">\n                          <img src={avatar_url} />\n                        </figure>\n                      </div>\n                      <div className=\"media-content\">\n                        <p className=\"title is-4\">{name}</p>\n                        <p className=\"subtitle is-6\">{this.props.viewingIdentity}</p>\n                      </div>\n                    </div>\n                \n                    <div className=\"content\">\n                      {bio}\n                      <br />\n                      <time datetime=\"2016-1-1\">\n                        {\n                          universe.moment(profile.data.data.createdAt,'x').fromNow()\n                        }\n                      </time>\n                    </div>\n                  </div>\n                </div>\n                \n              </div>\n            </div>\n          )\n          \n        }\n        \n        render(){\n          \n          let myIdentity = (this.props.state.OwnerSecondExternalIdentityNode && this.props.state.OwnerSecondExternalIdentityNode.data.identity == this.props.viewingIdentity) ? true:false;\n          \n          // console.log('myIdentity', this.props.state.OwnerSecondExternalIdentityNode, this.props.viewingIdentity);\n          \n          return (\n            <div className=\"columns\">\n              <div className=\"column is-6\">\n              \n                <br />\n                \n                {/* Creating Profile */}\n                {\n                  !myIdentity ? '':\n                  <div>\n                    <div className=\"level\">\n                      <div className=\"level-left\">\n                        <div className=\"level-item\">\n                        \n                          <button className={\"button is-info \" + (this.state.creatingProfile ? 'is-loading':'')} onClick={this.handleCreateNode}>\n                            Create Avatar\n                          </button>\n                          \n                        </div>\n                        <div className=\"level-item\">\n                        \n                        \n                          <div className=\"field\">\n                            <div className=\"control\">\n                              <div className=\"select\">\n                                <select onChange={this.handleUpdateProfileGroup} value={this.state.profileGroupNodeId}>\n                                  <option>Audience:</option>\n                                  {\n                                    this.props.groups.map(groupNode=>(\n                                      <option key={groupNode._id} value={groupNode._id}>{groupNode.data.name}</option>\n                                    ))\n                                  }\n                                  {\n                                    (!this.props.allExternalConnections.length && this.state.fetchingConnections) ?\n                                    <option>Loading groups</option>\n                                    :''\n                                  }\n                                </select>\n                              </div>\n                            </div>\n                          </div>\n                          \n                        </div>\n                      </div>\n                      \n                    </div>\n                    \n                    <hr />\n                    \n                  </div>\n                }\n                \n                \n                <div className=\"field has-addons\">\n                  <div className=\"control\">\n                    <button className={\"button is-default\"} onClick={e=>this.fetchFromRemoteForIdentity(this.props)}>\n                      Fetch Updates\n                    </button>\n                  </div>\n                  {\n                    !this.state.fetchingRemote ? '':\n                    <div className=\"control\">\n                      <a className=\"button is-loading\">\n                        &nbsp;\n                      </a>\n                    </div>\n                  }\n                </div>\n                   \n                <hr /> \n                \n                \n                <div>\n                  {\n                    this.renderProfiles()\n                  }\n                </div>\n                \n              </div>\n              \n              <div className=\"column is-6\">\n                {\n                  this.renderProfile()\n                }\n              </div>\n              \n            </div>\n          )\n        }\n      }\n      \n      mycomponent = universe.ReactGlobalState(mycomponent);\n      mycomponent = universe.ReactHelpers(mycomponent);\n      \n      const styles = {\n        deleteIcon: {\n          position: 'absolute',\n          top: '0px',\n          right: '-24px',\n          cursor: 'pointer'\n        }\n      }\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: mycomponent\n      });\n      \n    }catch(err){\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()",
    "internalId": "MainProfileComponent"
  }
}