{
  "type": "code:0.0.1:local:32498h32f2",
  "name": "code",
  "data": {
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      // Setting up Websockets \n      // - on server/browser (depending on WINDOW availability) \n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      switch(inputAction){\n        \n        case 'initLink':\n          // acts as the client/slave in websocket connection \n          // - creates connection to remote \n          // - upgrades connection using token (already should have authenticated!) \n          console.log('Websockets initLink capability');\n          \n          // INPUT: external identity node, to be updated with clientId of WINDOW.sockets \n          \n          // Manage clients\n          let clientId = universe.uuidv4();\n        \n          let ExternalIdentityNode = inputOpts.ExternalIdentityNode;\n          console.log('ExternalIdentityNode:', ExternalIdentityNode); // should be http or https (match current location, default https) \n          \n          let serverNode = ExternalIdentityNode.nodes.find(n=>{\n            return n.type.split(':')[0] == \"external_identity_connect_method\" && (['http','https'].indexOf(n.data.method) > -1)\n          })\n          \n          if(!serverNode){\n            console.error('Missing external_identity_connect_method for remote Second for websockets');\n            return false;\n          }\n          \n          let parser;\n          let connection;\n          \n          if(WINDOW){\n            parser = WINDOW.document.createElement('a');\n            parser.href = serverNode.data.connection;\n            connection = '//' + parser.host; // includes hostname:port. expecting same protocol as current host (http/https) \n          } else {\n            const { URL } = universe.require('url');\n            parser = new URL(serverNode.data.connection);\n            connection = '//' + parser.host; // includes hostname:port\n          }\n          \n          let io = universe.socketioClient;\n          \n          console.log('IO:', io);\n          console.log('socketioServers', universe.socketioServers);\n          console.log('connection', connection);\n          \n          // console.log('IO:', io);\n          let socket = io(connection); \n          \n          \n          // universe.socketioServers = universe.socketioServers || {};\n          universe.socketioServers[clientId] = { ExternalIdentityNode, socket };\n          \n          console.log('socketioServers set:', clientId);\n          \n          // Update local ExternalIdentityNode with clientId for websocket \n          // - create/update local node \n          let wsNode = ExternalIdentityNode.nodes.find(n=>{\n            return n.type.split(':')[0] == 'local_websocket_connection'\n          });\n          if(!wsNode){\n            // create \n            console.log('Creating wsNode');\n            wsNode = await universe.newNode({\n              nodeId: ExternalIdentityNode._id,\n              name: universe.uuidv4(),\n              type: 'local_websocket_connection:Qmf3289',\n              data: {\n                clientId,\n                status: null\n              }\n            });\n          } else {\n            // update \n            console.log('Updating wsNode');\n            wsNode.data.clientId = clientId;\n            wsNode.data.status = null;\n            wsNode = await universe.updateNode(wsNode);\n          }\n          \n          console.log('wsNode after create/update:', wsNode);\n          \n          socket.on('connect', async ()=>{\n            console.log('Connected websocket (listening)!');\n            \n            // Update status \n            wsNode.data.status = 'connected';\n            await universe.updateNode(wsNode);\n            \n            console.info('wsNode updated, now waiting for requests');\n            \n            // Handle incoming socket requests \n            // - runRequest \n              \n            socket.on('request', async (RequestNode, responseFunc)=>{\n            \t// let requestId = uuidv4();\n             //  console.log('RequestNode:', RequestNode);\n             \n             console.log('GOT REQUEST FROM SERVER!!!!', RequestNode); // Not expecting this yet, not running\n          \n          \t\tresponseFunc = responseFunc || function(data){\n          \t\t\tconsole.log('Response (NOT sent back to requesting client, no responseFunc provided:', data);\n          \t\t}\n          \t\t\n          \t\t// responseFunc({\n          \t\t//   secondResponse: {\n            // \t\t  type: 'responding_from_client:Qmsfkldj',\n            // \t\t  data: {\n            // \t\t    responseFromClient: true\n            // \t\t  }\n          \t\t//   }\n          \t\t// });\n          \n          \t\t// app.secondAI.incomingAIRequestSocketIO({\n          \t\t// \ttype: 'request',\n          \t\t// \tdata: RequestNode,\n          \t\t// \tclientId,\n          \t\t// \tresponseFunc\n          \t\t// });\n            \t\t\n            \t\t\n              // cache the route-finding code \n              let cacheAppId = universe.getParentRoot(SELF)._id;\n              let cache = ['incoming_from_uni', cacheAppId].join('|');\n              \n              // app root-level (old: global-root) \n              let uniNodes = await universe.searchMemory({\n                cache,\n                filter: {\n                  dataFilter: {\n                    // nodeId: null // OLD: root-level\n                    type: {\n                      $like: 'incoming_from_uni'\n                    }\n                  },\n                  filterNodes: tmpNodes=>{\n                    return new Promise((resolve, reject)=>{\n                      tmpNodes = tmpNodes.filter(tmpNode=>{\n                        return universe.sameAppPlatform(SELF, tmpNode);\n                      });\n                      resolve(tmpNodes);\n                    });\n                  },\n                }\n              });\n              \n              if(!uniNodes.length){\n                console.error('Missing \"incoming_from_uni\" for socketio requests');\n                return false;\n              }\n              \n              let uniNode = uniNodes[0];\n              let codeNode = uniNode.find(n=>{\n                return n.type.split(':')[0] == 'code'\n              })\n              \n              try {\n                // Handle request using normal flow (creates new Request w/ requestId, new cache, etc) \n                await universe.runRequest(RequestNode, false, clientId, responseFunc);\n              }catch(err){\n                console.error('Failed websocket request/response (runRequest failed):', err);\n              }\n              \n              // responseFunc(responseNode);\n              \n          \n            });\n            \n            \n            // Run capability for websocket authentication \n            // - so that the remote (master) websocket server can know which external_identity the websocket is for \n            // - also linking local OwnerSecondExternalIdentityNode to socket, for TalkToSecond \n            \n            let linkRequestNode = {\n              type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n              data: {\n                actions: [\n                  {\n                    matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                    dataForAction: {\n                      type: 'string:...',\n                      data: ExternalIdentityNode.data.token\n                    }\n                  },\n                  {\n                    matchActionType: 'link_websocket_to_identity:Qmf2398sdoihf',\n                    dataForAction: {\n                      type: 'options_object:...',\n                      data: {}\n                    }\n                  },\n                ]\n                \n              }\n            }\n            console.log('Emitting linkRequestNode for websocket clientId upgrade');\n            socket.emit('request', linkRequestNode, async (ResponseNode)=>{\n              console.log('Response from server for linkRequestNode (via websocket)', ResponseNode);\n            });\n            \n            \n            \n          });\n          // socket.on('event', function(data){});\n          socket.on('disconnect', async ()=>{\n            console.log('disconnected websocket');\n            \n            wsNode.data.status = 'disconnected';\n            await universe.updateNode(wsNode);\n            \n          });\n          \n          socket.on('error', async (err)=>{\n            console.error('Websocket Error:', err);\n          });\n          \n          // WINDOW.SOCKET = socket;\n          \n        \n          return resolve({\n            type:'boolean:...',\n            data: true\n          })\n          \n        \n        default:\n          break;\n      }\n      \n      return reject();\n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()",
    "key": "cae006a6-7c84-4de4-b87b-5ef7c675440a"
  }
}