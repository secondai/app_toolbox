{
  "type": "react_component:0.0.1:local:98912hd89",
  "name": "SituationListActionsComponent",
  "data": {
    "author": "-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCcuXovU+RZy85KMqLakYSH1mdV\nWdpEUtgcXUyGyU5hVeTO7BkV/kxeC2upcxOwNnrBOdsvHI3nrrILgt90/hCSHKzx\nhOFLREorGoKtSEHxI7/SnzzlWtV3gT/IP5GVHIyvuJBx3hCti0dH55DZG8iMGZ2y\ncGpV73Dez3hHmeBh6wIDAQAB\n-----END PUBLIC KEY-----",
    "version": "1",
    "key": "f54dcabd-3790-4644-88fd-a6fc55d997aa",
    "code": "(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      const AceEditor = universe.AceEditor;\n      const ReactResizeDetector = universe.ReactResizeDetector;\n      const RecreateChildOnPropsChange = universe.RecreateChildOnPropsChange;\n      \n      const Select = universe.ReactSelect;\n      \n      const ReactSortableContainer = universe.ReactSortableContainer;\n      const ReactSortableElement = universe.ReactSortableElement;\n      const ReactSortableArrayMove = universe.ReactSortableArrayMove;\n      \n      class SortableItem extends React.Component {\n        constructor(props){\n          super(props);\n          \n          let node = this.props.value;\n          \n          this.state = {\n            node,\n            editing: false,\n          }\n        }\n        \n        componentDidMount(){\n          this.handleKeyDown();\n        }\n        \n        componentWillReceiveProps(nextProps){\n          this.setState({\n            node: nextProps.value\n          });\n        }\n        \n        \n        @autobind\n        startEditing(){\n          console.log('startEditing', this.state.node);\n          \n          let code;\n          try {\n            code = this.state.node.data.code;\n          }catch(err){\n            console.error('invalid code value! not a string (should have been):', this.state.node, err);\n            code = 'ERROR!'\n          }\n          \n          this.setState({\n            editing: true,\n            plain: this.state.node.data.plain,\n            value: code\n          });\n        }\n        \n        @autobind\n        closeEditor(){\n          this.setState({\n            editing: false\n          });\n        }\n        \n        @autobind\n        handleSave(){\n          console.log('saving');\n          \n          // Verify it is an object (not an array) \n          let code = this.state.value;\n          \n          let node = this.state.node;\n          node.data.plain = this.state.plain;\n          node.data.code = code;\n          \n          this.props.makeSaveRequest(node);\n          \n          this.setState({\n            editing: false\n          });\n          \n        }\n      \n        @autobind\n        handleKeyDown(e){\n          if(this.aceRef && this.aceRef.editor){\n            this.aceRef.editor.commands.addCommand({\n              name: 'save',\n              bindKey: {\n                win: 'Ctrl-S',\n                mac: 'Command-S'\n              },\n              exec: (env, args, request)=>{\n                this.handleSave();\n              }\n            });\n            \n            // overwrite Cmd-D to same as sublime \n            this.aceRef.editor.commands.addCommand({\n              name: 'selectMoreAfter2',\n              bindKey: {\n                win: 'Ctrl-D',\n                mac: 'Command-D'\n              },\n              exec: (env, args, request)=>{\n                // selectMoreAfter\n                this.aceRef.editor.execCommand(\"selectMoreAfter\")\n              }\n            });\n          }\n      \n        }\n        \n        @autobind\n        handleDelete(){\n          \n          let node = this.state.node;\n          \n          this.props.makeDeleteRequest(node);\n          \n        }\n        \n        render(){\n          let node = this.state.node;\n          \n          return (\n            <div>\n              { !this.state.editing ? \n                <div style={{cursor:'pointer'}}>\n                  {(node.data.position || 0) + 1}. \"{\n                    node.data.plain\n                  }\" <span className='icon' onClick={this.startEditing}><i className='fa fa-edit'></i></span>\n                  <span className='icon' onClick={this.handleDelete}><i className='fa fa-trash'></i></span>\n                </div>\n              :\n              <div>\n                <input type=\"text\" value={this.state.plain} onChange={e=>this.setState({plain:e.target.value})} className=\"input\" />\n                <br />\n                <div style={{height: '300px'}}>\n                  <AceEditor\n                    ref={r=>this.aceRef=r}\n                    mode=\"jsx\"\n                    theme=\"monokai\"\n                    value={this.state.value}\n                    onChange={value=>{\n                      this.setState({value});\n                    }}\n                    editorProps={{$blockScrolling: true}}\n                    width=\"100%\"\n                    height=\"100%\"\n                    onLoad={editor=>{\n                      editor.getSession().setUseWrapMode(true);\n                    }}\n                    setOptions={{\n                      enableBasicAutocompletion: true,\n                      enableLiveAutocompletion: true,\n                      showPrintMargin: false,\n                      enableSnippets: true,\n                      behavioursEnabled: false,\n                      showLineNumbers: true,\n                      tabSize: 2\n                    }}\n                  />\n                </div>\n                \n                <div className=\"field is-grouped\">\n                  <p className=\"control\">\n                    <button className=\"button is-success\" onClick={this.handleSave}>\n                      Save\n                    </button>\n                  </p>\n                  <p className=\"control\">  \n                    <button className=\"button is-default\" onClick={this.closeEditor}>\n                      Cancel\n                    </button>\n                  </p>\n                </div>\n                \n              </div>\n              }\n              \n            </div>\n          )\n        }\n      }\n                    \n      SortableItem = ReactSortableElement(SortableItem);\n           \n      class SortableList extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              {this.props.items.map((value, index) => (\n                <SortableItem \n                  key={`item-${index}`} \n                  index={index} \n                  value={value} \n                  makeSaveRequest={this.props.makeSaveRequest}\n                  makeDeleteRequest={this.props.makeDeleteRequest}\n                />\n              ))}\n            </div>\n          );\n        }\n      }\n      \n      SortableList = ReactSortableContainer(SortableList); //({items}) => {\n      \n      // SortableList = universe.sharedComponents.withEditableNodeInfo(SortableList, {\n      //   editNodePath: 'app_toolbox/platform_browser/react_components/DefaultLayout',\n      //   editNodeId: '5af76ca59c4742002112b884'\n      // });   \n      \n      \n    \n      class mycomponent extends React.Component {\n        constructor(props){\n          super(props);\n          \n          this.state = {\n            PossibleRuleNodes: [],\n            options: [],\n            value: null, // Select.Creatable value (value.node if existing) \n            codeValue: null\n          }\n          \n        }\n        \n        componentDidMount(){\n          if(this.props.initEditComponent){\n            this.props.initEditComponent(this);\n          }\n          \n          this.fetchPossibleActions();\n          this.fetchPossibleRules();\n        }\n        \n        @autobind\n        getBuilderNode(){\n          \n          let builder = universe.lodash.query(this.props.situationMatchActionNode.nodes,{\n            type: {\n              $like: 'situation_action_builder:'\n            }\n          });\n          if(!builder.length){\n            // no actions!\n            return (<div>No Actions</div>);\n          }\n          builder = builder[0];\n          \n          return builder;\n          \n        }\n        \n        @autobind\n        getBuilderNodes(){\n          \n          let builder = this.getBuilderNode();\n          \n          let builderNodes = builder.nodes.sort((a,b)=>{\n            return (a.data.position - b.data.position)\n          });\n          \n          return builderNodes;\n          \n        }\n        \n        @autobind\n        fetchPossibleActions(){\n          // get all posibilities for \"situation_action_builder\" nodes \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n              \n              this.setState({\n                fetchingActions: true\n              })\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          \n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                      \n                          {\n                            matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                            dataForAction: {\n                              type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              data: {\n                                dataFilter: {\n                                  'parent.type' : {\n                                    $like: 'situation_action_builder:'\n                                  }\n                                },\n                                actionFunctionNode: null\n                              }\n                            }\n                          }\n                          \n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              let nodes = response.data.actionResponses[1].data;\n              \n              // Create trees from nodes (in_reply_to) \n              // - get all of my unique Posts \n              let PossibleActionNodes = nodes;\n              \n              \n              console.log('PossibleActionNodes', PossibleActionNodes);\n              \n              let options = PossibleActionNodes.map(node=>{\n                return {\n                  label: node.data.plain,\n                  value: node._id,\n                  node\n                }\n              })\n              \n              // let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                PossibleActionNodes,\n                options\n              })\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n            }\n          \n            this.setState({\n              fetchingActions: false\n            })\n            \n          });\n          \n        }\n        \n        @autobind\n        fetchPossibleRules(){\n          // get all posibilities for \"situation_match_builder\" nodes \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n              \n              this.setState({\n                fetchingRules: true\n              })\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          \n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                      \n                          {\n                            matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                            dataForAction: {\n                              type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              data: {\n                                dataFilter: {\n                                  'type' : {\n                                    $like: 'action_rule:'\n                                  },\n                                  nodeId: null // root-level only!\n                                },\n                                matchFunctionNode: null\n                              }\n                            }\n                          }\n                          \n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              let nodes = response.data.actionResponses[1].data;\n              \n              // Create trees from nodes (in_reply_to) \n              // - get all of my unique Posts \n              let PossibleRuleNodes = nodes;\n            \n              this.setState({\n                PossibleRuleNodes\n              })\n              \n            } catch(err){\n              console.error('Failed getting PossibleRuleNodes');\n            }\n          \n            this.setState({\n              fetchingRules: false\n            })\n            \n          });\n          \n        }\n        \n        @autobind\n        onSortStartActions(){\n          console.log('Sort started!');\n        }\n        \n        @autobind\n        onSortEndActions(indexes, newIndex){\n          // console.log('ended sort', oldIndex, newIndex);\n          \n          // // Update each node's position, if changed\n          // let builderNodes = JSON.parse(JSON.stringify(this.state.builderNodes));\n          // // let tmpOut = builderNodes.slice(oldIndex);\n          // let gotNode = builderNodes.splice(oldIndex,1);\n          // console.log('SplicedGotNode:', oldIndex, newIndex, gotNode); //gotNode.data.plain, gotNode);\n          // // builderNodes.splice(newIndex,0,tmpOut[0]);\n          // // builderNodes.push(tmpOut[0]);\n          \n          let builderNodes = ReactSortableArrayMove(this.getBuilderNodes(), indexes.oldIndex, indexes.newIndex);\n          \n          // console.log('Now builderNodes', oldIndex, newIndex, builderNodes);\n          \n          let toSave = [];\n          \n          builderNodes = builderNodes.map((node,position)=>{\n            console.log(position, node.data.plain, node);\n            if(node.data.position != position){\n              node.data.position = position;\n              toSave.push(node);\n            }\n            return node;\n          });\n          \n          console.log('toSave:', toSave.length, toSave);\n          for(let nodeToSave of toSave){\n            this.makeSaveRequest(nodeToSave);\n          }\n          \n          // this.setState({\n          //   builderNodes\n          // });\n          \n          // TODO: save changed! \n          \n        }\n        \n        @autobind\n      \thandleOnChangeNew(value){\n      \t  \n      \t  if(!value){\n      \t    return this.setState({value});\n      \t  }\n      \t  \n      \t  \n      \t // console.log('VALUE:', value);\n      \t \n      \t  // new or existing?\n      \t  if(value.node){\n      \t    // existing \n      \t  } else {\n      \t    // new\n      \t    value.node = {\n      \t      data: {\n      \t        plain: value.label,\n      \t        code: \"\",\n      \t      }\n      \t    }\n          }\n      \t  \n          let codeValue;\n          try {\n            codeValue = value.node.data.code;\n          }catch(err){\n            console.error('invalid code value! not a string (should have been):', this.state.node, err);\n            codeValue = 'ERROR!'\n          }\n          \n      \t\tthis.setState({ \n      \t\t  value,\n      \t\t  codeValue\n      \t\t});\n      \t}\n        \n        @autobind\n        async handleCreateActionBuilderNode(){\n          \n          // Add a node to the action builder \n          console.log('handleCreateActionBuilderNode');\n          let builder = universe.lodash.query(this.props.situationMatchActionNode.nodes,{\n            type: {\n              $like: 'situation_action_builder:'\n            }\n          });\n          if(!builder.length){\n            // no actions!\n            return console.error('Missing situation_action_builder');\n          }\n          builder = builder[0];\n          \n          console.log('builder', builder);\n          \n          let code = this.state.codeValue;\n          \n          \n          let node = {\n            nodeId: builder._id,\n            name: universe.uuidv4(),\n            type: 'action_temp:Qmsldfj',\n            data: {\n              plain: this.state.value.node.data.plain,\n              code,\n              position: builder.nodes.length\n            }\n          }\n          \n          console.log('Creating:', node);\n          \n          let createNodeResponse = await this.createNodeOnSecond(node);\n          \n          console.log('createNodeResponse', createNodeResponse);\n          \n          \n          this.setState({\n            value: null,\n            codeValue: null\n          });\n          \n          if(this.props.onUpdate){\n            this.props.onUpdate();\n          }\n          \n        }\n        \n        @autobind\n        async handleCompileAction(){\n          // compile action_builder nodes into single query for actioning \n          // - TODO: handle server-side, with ML \n          \n          // Add a node to the action builder \n          console.log('handleCompileAction');\n          let existingActionNode = universe.lodash.query(this.props.situationMatchActionNode.nodes,{\n            type: {\n              $like: 'situation_action:'\n            }\n          });\n          if(!existingActionNode.length){\n            // no actions!\n            return console.error('Missing existing situation_action');\n          }\n          existingActionNode = existingActionNode[0];\n          \n          \n          let builder = universe.lodash.query(this.props.situationMatchActionNode.nodes,{\n            type: {\n              $like: 'situation_action_builder:'\n            }\n          });\n          if(!builder.length){\n            // no actions!\n            return console.error('Missing situation_action_builder');\n          }\n          builder = builder[0];\n          \n          let builderNodes = builder.nodes.sort((a,b)=>{\n            return (a.data.position - b.data.position)\n          });\n          \n          let queries = builderNodes.map(builderNode=>{\n            return JSON.parse(builderNode.data.query);\n          });\n          \n          existingActionNode.data.query = JSON.stringify({\n            $and: queries\n          })\n          \n          console.log('Saving existingActionNode', existingActionNode);\n          \n          await this.makeSaveRequest(existingActionNode);\n          \n          \n        }\n        \n        @autobind\n        makeSaveRequest(nodeToSave, opts, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            this.setState({\n              saving: true\n            })\n            \n            opts = opts || {};\n            \n            // Make request to save Node on remote \n            try {\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                          {\n                            matchActionType: 'update_node:0.0.2:local:392821982y3',\n                            dataForAction: {\n                              type: 'update_node_data:0.0.2:local:123445',\n                              data: {\n                                optionsNode: {\n                                  type: 'options_generic:0.0.1:local:289f3j29832',\n                                  data: opts || {}\n                                },\n                                dataNode: nodeToSave\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('Update response:', response);\n              \n              if(skipEvent !== true){\n                try {\n                  universe.EE.emit('nodes-modified', '');\n                }catch(err){\n                  console.error(err);\n                }\n              }\n              \n              this.setState({\n                saving: false\n              })\n              \n              return resolve({\n                type: 'node:...',\n                data: response.data.actionResponses[1]\n              });\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              alert('Failed');\n              \n              this.setState({\n                saving: false\n              })\n              \n              return reject();\n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        async makeDeleteRequest(node){\n          // removes from list also \n          \n          node.active = false;\n          \n          await this.makeSaveRequest(node);\n          \n          // Update positions of builder nodes\n          let builderNodes = this.getBuilderNodes();\n          universe.lodash.remove(builderNodes, n=>{\n            return n._id == node._id;\n          });\n          \n          \n          // console.log('Now builderNodes', oldIndex, newIndex, builderNodes);\n          \n          let toSave = [];\n          \n          builderNodes = builderNodes.map((node,position)=>{\n            console.log(position, node.data.plain, node);\n            if(node.data.position != position){\n              node.data.position = position;\n              toSave.push(node);\n            }\n            return node;\n          });\n          \n          console.log('toSave:', toSave.length, toSave);\n          for(let nodeToSave of toSave){\n            await this.makeSaveRequest(nodeToSave);\n          }\n          \n          console.log('After save, update selected');\n          \n          if(this.props.onUpdate){\n            this.props.onUpdate();\n          }\n          \n        }\n        \n        @autobind\n        createNodeOnSecond(nodeToSave){\n          return new Promise(async (resolve, reject) => {\n            \n            console.log('NewNode:', nodeToSave);\n                \n            // Make request to save Node on remote \n            try {\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          \n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                          \n                          {\n                            matchActionType: 'create_node:Qmf3892j39f8h9babb',\n                            dataForAction: {\n                              type: 'create_node_data:Qmdslkfj29f0j82',\n                              data: {\n                                optionsNode: {\n                                  type: 'options_generic:0.0.1:local:289f3j29832',\n                                  data: {}\n                                },\n                                dataNode: nodeToSave\n                              }\n                            }\n                          }\n                        ]\n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('create_node response:', response);\n              \n              // get the created node \n              let savedNode = response.data.actionResponses[1];\n              \n              return resolve(savedNode);\n              \n            } catch(err){\n              console.error('Failed creating new node', err);\n            }\n            \n          })\n        }\n        \n        @autobind\n        async handleResetRules(){\n          // remove all rule-added actions \n          console.log('reset rules');\n          \n          let builderNode = this.getBuilderNode();\n          let builderNodes = this.getBuilderNodes();\n          \n          // Reset rules first \n          // - removes all existing action_from_rule \n          //   - add to toRemove \n          let toRemove = [];\n          for(let actionNode of builderNodes){\n            let idx = builderNodes.indexOf(actionNode);\n            if(actionNode.type.split(':')[0] == 'action_from_rule'){\n              toRemove.push(actionNode);\n              builderNodes.splice(idx,1); // remove from array \n            }\n          }\n          \n          // remove (makeSaveRequest) \n          for(let removeNode of toRemove){\n            removeNode.active = false;\n            await this.makeSaveRequest(removeNode);\n          }\n          \n          // reset positions \n          let toSave = [];\n          \n          builderNodes = builderNodes.map((node,position)=>{\n            console.log('Found:', position, node.data.plain, node);\n            if(node.data.position != position){\n              node.data.position = position;\n              toSave.push(node);\n              console.log('need toSave this one');\n            }\n            return node;\n          });\n          \n          console.log('toSave:', toSave.length, toSave);\n          for(let nodeToSave of toSave){\n            this.makeSaveRequest(nodeToSave);\n          }\n          \n          if(this.props.onUpdate){\n            this.props.onUpdate();\n          }\n          \n        }\n        \n        @autobind\n        async handleProcessRules(){\n          // run all the Rules against actions \n          // - will insert new ones, ideally! \n          \n          console.log('handleProcessRules');\n          let builderNode = this.getBuilderNode();\n          let builderNodes = this.getBuilderNodes();\n          \n          // Reset rules first \n          // - removes all existing action_from_rule \n          //   - add to toRemove \n          let toRemove = [];\n          for(let actionNode of builderNodes){\n            let idx = builderNodes.indexOf(actionNode);\n            if(actionNode.type.split(':')[0] == 'action_from_rule'){\n              toRemove.push(actionNode);\n              builderNodes.splice(idx,1); // remove from array \n            }\n          }\n          \n          // remove (makeSaveRequest) \n          for(let removeNode of toRemove){\n            removeNode.active = false;\n            await this.makeSaveRequest(removeNode);\n          }\n          \n          \n          // iterate over rules \n          for(let ruleNode of this.state.PossibleRuleNodes){\n            console.log('rule');\n            \n            let matchNode = ruleNode.nodes.find(n=>{\n              return n.type.split(':')[0] == 'rule_match'\n            });\n            if(!matchNode){\n              console.error('Rule missing matchNode', ruleNode);\n              continue;\n            }\n            let actionNode = ruleNode.nodes.find(n=>{\n              return n.type.split(':')[0] == 'rule_action'\n            });\n            if(!actionNode){\n              console.error('Rule missing actionNode', ruleNode);\n              continue;\n            }\n            \n            // matches? \n            // - duplicates prevented from being added \n            let matches = universe.lodash.query(builderNodes, JSON.parse(matchNode.data.query));\n            console.log('Matches for ruleNode:', matches.length, matches);\n            if(matches.length){\n              for(let matchedBuilderActionNode of matches){\n                console.log('TEST1');\n              }\n              for(let matchedBuilderActionNode of matches){\n                // determine if already added \n                // - TODO: this should be defined by the element itself, to allow recursion? (matching should include \"dont recurse\" condition/logic) \n                \n                console.log('Creating New Action From Rule', matchedBuilderActionNode);\n                let matchedBuilderActionNodeIdx = builderNodes.indexOf(matchedBuilderActionNode);\n                if(matchedBuilderActionNodeIdx == -1){\n                  console.error('Not a valid node');\n                  continue;\n                }\n                \n                console.log('matchedBuilderActionNodeIdx:', matchedBuilderActionNodeIdx);\n                \n                let newActionFromRuleNode = {\n                  nodeId: builderNode._id,\n                  type: 'action_from_rule:Qmfklj2',\n                  name: universe.uuidv4(),\n                  data: {\n                    plain: ruleNode.data.plain,\n                    code: actionNode.data.code,\n                    position: 0,\n                    matchNode: matchNode // for fun \n                  }\n                }\n                \n                // create on server, get id \n                // - TODO: better way updating everything (bulk) \n                let savedActionFromRuleNode = await this.createNodeOnSecond(newActionFromRuleNode);\n                \n                console.log('savedActionFromRuleNode', savedActionFromRuleNode);\n                \n                // get the actual node, not just the response \n                savedActionFromRuleNode = savedActionFromRuleNode.data; \n                \n                if(matchNode.data.location == 'before'){\n                  // push at same location \n                  builderNodes.splice(matchedBuilderActionNodeIdx, 0, savedActionFromRuleNode);\n                } else if(matchNode.data.location == 'after') {\n                  // push after\n                  builderNodes.splice(matchedBuilderActionNodeIdx + 1, 0, savedActionFromRuleNode);\n                }\n                \n              }\n            }\n            \n          }\n          \n          // reset positions \n          let toSave = [];\n          \n          builderNodes = builderNodes.map((node,position)=>{\n            console.log('Found:', position, node.data.plain, node);\n            if(node.data.position != position){\n              node.data.position = position;\n              toSave.push(node);\n              console.log('need toSave this one');\n            }\n            return node;\n          });\n          \n          console.log('toSave:', toSave.length, toSave);\n          for(let nodeToSave of toSave){\n            this.makeSaveRequest(nodeToSave);\n          }\n          \n          console.log('Done processing Rules');\n          \n          if(this.props.onUpdate){\n            this.props.onUpdate();\n          }\n          \n        }\n        \n        render(){\n          \n          let builderNodes = this.getBuilderNodes();\n          \n          // this.setState({\n          //   builderNodes\n          // });\n          // let builderNodes = this.state.builderNodes;\n          \n          return (\n            <div>\n              <link rel=\"stylesheet\" type=\"text/css\" href='https://unpkg.com/react-select@1.2.1/dist/react-select.css' />\n              \n            \n              <div className=\"field is-grouped\">\n                <p className=\"control\">\n                  <button className=\"button is-info\" onClick={this.handleProcessRules}>\n                    Process Rules\n                  </button>\n                </p>\n                <p className=\"control\">\n                  <button className=\"button\" onClick={this.handleResetRules}>\n                    Clear Rules\n                  </button>\n                </p>\n              </div>\n              \n              <br />\n              \n              <SortableList \n                items={builderNodes} \n                pressDelay={150}\n                onSortStart={this.onSortStartActions} \n                onSortEnd={this.onSortEndActions} \n                makeSaveRequest={this.makeSaveRequest}\n                makeDeleteRequest={this.makeDeleteRequest}\n              />\n              \n              <br />\n              <div>\n                \n                <Select.Creatable\n        \t\t\t\t\tmulti={false}\n        \t\t\t\t\toptions={this.state.options}\n        \t\t\t\t\tonChange={this.handleOnChangeNew}\n        \t\t\t\t\tvalue={this.state.value}\n        \t\t\t\t\tshowNewOptionAtTop={true}\n        \t\t\t\t\topenOnClick={false}\n        \t\t\t\t/>\n        \t\t\t\t\n                { !this.state.codeValue ? '':\n                <div>\n                  <div style={{height: '300px'}}>\n                    <AceEditor\n                      ref={r=>this.aceRef=r}\n                      mode=\"jsx\"\n                      theme=\"monokai\"\n                      value={this.state.codeValue}\n                      onChange={codeValue=>{\n                        this.setState({codeValue});\n                      }}\n                      editorProps={{$blockScrolling: true}}\n                      width=\"100%\"\n                      height=\"100%\"\n                      onLoad={editor=>{\n                        editor.getSession().setUseWrapMode(true);\n                      }}\n                      setOptions={{\n                        enableBasicAutocompletion: true,\n                        enableLiveAutocompletion: true,\n                        showPrintMargin: false,\n                        enableSnippets: true,\n                        behavioursEnabled: false,\n                        showLineNumbers: true,\n                        tabSize: 2\n                      }}\n                    />\n                  </div>\n                </div>\n                }\n                \n                <button className=\"button is-success\" onClick={this.handleCreateActionBuilderNode}>\n                  Save New\n                </button>\n                \n              </div>\n            </div>\n          )\n\n        }\n      }\n      \n      mycomponent = universe.sharedComponents.withEditableNodeInfo(mycomponent, {\n        localNode: SELF\n      });\n      \n      mycomponent = universe.ReactGlobalState(mycomponent);\n      mycomponent = universe.ReactHelpers(mycomponent);\n      mycomponent = universe.ReactRouterDomWithRouter(mycomponent);\n      \n            \n      const styles = {\n        deleteIcon: {\n          position: 'absolute',\n          top: '0px',\n          right: '-24px',\n          cursor: 'pointer'\n        }\n      }\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: mycomponent\n      });\n      \n    }catch(err){\n      console.error(err);\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()",
    "internalId": "SituationListActionsComponent"
  }
}