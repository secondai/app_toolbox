{
  "type": "react_component:0.0.1:local:98912hd89",
  "name": "MainHomeComponent",
  "data": {
    "author": "-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCcuXovU+RZy85KMqLakYSH1mdV\nWdpEUtgcXUyGyU5hVeTO7BkV/kxeC2upcxOwNnrBOdsvHI3nrrILgt90/hCSHKzx\nhOFLREorGoKtSEHxI7/SnzzlWtV3gT/IP5GVHIyvuJBx3hCti0dH55DZG8iMGZ2y\ncGpV73Dez3hHmeBh6wIDAQAB\n-----END PUBLIC KEY-----",
    "version": "1",
    "key": "1424caa3-2102-49dc-abf6-6aef966076f2",
    "code": "(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      const AceEditor = universe.AceEditor;\n      const ReactResizeDetector = universe.ReactResizeDetector;\n      const RecreateChildOnPropsChange = universe.RecreateChildOnPropsChange;\n      \n      class EmbeddedComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              embeddedComponenthere\n            </div>\n          )\n        }\n      }\n      \n      let ErrorComponent = (name) => {\n        return class ErrorComponent extends React.Component {\n          constructor(props){\n            super(props);\n          }\n          render(){\n            return (\n              <div>\n                ErrorLoading: {name || 'unknown'}\n              </div>\n            )\n          }\n        }\n      }\n      \n      class mycomponent extends React.Component {\n        constructor(props){\n          super(props);\n          \n          this.state = {\n            targetData: {}, \n            metadataData: {}, \n            metadataResults: [],\n            possibleTargetTypes: [],\n            possibleMetadataTypes: [],\n            targetType: null,\n            metadataType: null,\n            createPrivate: true,\n            tabMain: 'all',\n            newMessageText: '',\n            tabData: 'profile',\n            viewIdentity: '',\n            viewingIdentity: '', // updated after clicking \"get updates\" or \"view\" \n            viewIdentityType: 'idtest',\n            identityTypes: ['id','idtest','twitter'],\n            searchIdentity: 'idtest:fb',\n            notes: [],\n            results: [],\n            groups: [],\n            allExternalConnections: [],\n            searchText: '',\n            postGroupNodeId: '', \n            isSearching: false,\n          }\n        }\n        \n        componentDidMount(){\n          \n          console.log('Loaded MainHomeComponent');\n            \n          this.startup();\n          \n          let viewIdentity,\n            viewIdentityType,\n            viewIdentitySplit;\n          \n          viewIdentitySplit = this.props.state.OwnerSecondExternalIdentityNode.data.identity.split(':');\n          viewIdentityType = viewIdentitySplit[0];\n          viewIdentity = viewIdentitySplit.slice(1).join(':');\n          \n          // update default viewIdentity\n          if(this.props.state.OwnerSecondExternalIdentityNode){\n            this.setState({\n              viewIdentity,\n              viewIdentityType\n            });\n          }\n            \n        }\n        \n        @autobind\n        async startup(){\n          \n          this.fetchPossibleMetadataTypes();\n          this.fetchGroups();\n          this.fetchExternalConnections();\n          \n          await this.loadComponents();\n          \n        }\n        \n        @autobind\n        async loadComponents(){\n          \n          // Not async for setState! \n          \n          let components = [\n            'MainProfileComponent',\n            'MainSitesComponent',\n            'MainPostsComponent',\n            'MainMarketplaceComponent',\n          ];\n          \n          for(let componentInternalId of components){\n            try {\n                \n              let Component = await this.props.loadComponent({\n                internalId: componentInternalId\n              });\n              let obj = {};\n              obj[componentInternalId] = Component;\n              this.setState(obj)\n              // console.log(componentInternalId,Component);\n              \n            }catch(err){\n              console.error(\"Failed loading component:\",componentInternalId);\n            }\n          }\n          \n        }\n        \n        @autobind\n        fetchPossibleMetadataTypes(){\n          \n          return new Promise(async (resolve,reject)=>{\n            \n            this.setState({\n              fetchingPossibleTargetTypes: true\n            });\n            \n            let possibleTargetTypes = [\n              ['URL','metadata_target_url:Qm32fj923f23fsdf',{\n                groupByField: 'url' // in node.data\n              }],\n              ['Email','metadata_target_email:Qm89sfdf893fhhfd',{\n                groupByField: 'email' // in node.data\n              }],\n              // ['File','metadata_target_file:Qm3289fh98f23f',{\n                \n              // }]\n            ];\n            \n            \n            \n            let possibleMetadataTypes = [\n              ['Note','metadata_note:Qmf829h322332fsdf',{\n                groupByField: 'note' // in node.data\n              }],\n              ['Tags','metadata_tags:Qm390dj2309f23',{\n                groupByField: 'tags' // in node.data\n              }],\n              ['Star Rating (1-5)','metadata_stars_1_5:Qm099020f3290j23f',{\n                groupByField: 'rating' // in node.data\n              }]\n            ];\n            \n            // let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n            //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n            //   data: {\n            //     action: 'send',\n            //     options: {\n            //       ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n            //       RequestNode: {\n            //         type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n            //         data: {\n            //           actions: [\n            //             {\n            //               matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n            //               dataForAction: {\n            //                 type: 'standard_query_request:0.0.1:local:65723f2khfds',\n            //                 data: {\n            //                   matchFunctionNode: {\n            //                     // query here!\n            //                     // action_pointer:0.0.1:local:238972ncr\n            //                     type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n            //                     data: {\n            //                       code: `(()=>{\n            //                         // Action \n            //                         // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                    \n            //                         let inputNode = INPUT.data.inputNode;\n                                    \n            //                         if(inputNode.nodeId){\n            //                           return false;\n            //                         }\n                                    \n            //                         if(inputNode.type.split(':')[0] != 'group_for_sharing'){\n            //                           return false;\n            //                         }\n                                    \n            //                         return inputNode;\n                                    \n            //                       })()`\n            //                     }\n            //                   },\n            //                   // expected/allowed schemas for return \n            //                   // outputSchemas: [\n            //                   //   'query_result:0.0.1:local:32490usfj23o23f',\n            //                   //   'internal_error_output:0.0.1:local:32948x2u3cno2c'\n            //                   // ]\n            //                 }\n            //               }\n            //             }\n            //           ]\n                      \n            //         }\n            //       }\n            //     }\n            //   }\n            // });\n            \n            // // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n            // let nodes = response.data.actionResponses[0].data;\n            \n            \n            \n            this.setState({\n              possibleTargetTypes,\n              possibleMetadataTypes,\n              fetchingPossibleTargetTypes: false\n            }, resolve);\n            \n          });\n          \n        }\n        \n        \n        @autobind\n        fetchMetadata(){\n          \n          return new Promise(async (resolve,reject)=>{\n            \n            this.setState({\n              fetchingMetadata: true\n            });\n            \n            let searchText = this.state.searchText;\n            \n            let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n              type: 'standard_capability_action:0.0.1:local:298j291bs',\n              data: {\n                action: 'send',\n                options: {\n                  ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                  RequestNode: {\n                    type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                    data: {\n                      actions: [\n                      \n                        {\n                          matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                          dataForAction: {\n                            type: 'string:...',\n                            data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                          }\n                        },\n                        \n                        {\n                          matchActionType: 'search_shared_data:Qmksdjhfwekjhdds24f',\n                          dataForAction: {\n                            // type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                            type: 'shared_data_request:Qmsdfljsdj',\n                            data: {\n                              // // TODO: searchableFilter is for normalizing search across multiple types \n                              // // - not sure if want to search this way, or define specific types to search for using dataFilter\n                              // // - searchableFilter will use search-index (Norch) for now \n                              // searchableFilter: {\n                              //   text: searchText,\n                              //   // TODO: tags, etc. to be parsed? \n                              // },\n                              \n                              // filter on the ENTIRE shared_node (NOT just on the shared_node data) \n                              // - specifying how to search each type \n                              dataFilter: {\n                                $or: [{\n                                  'data.data.target.type': {\n                                    $like: 'metadata_target_email:'\n                                  },\n                                  'data.data.target.data.email': {\n                                    $like: searchText\n                                  }\n                                },{\n                                  'data.data.metadata.type': {\n                                    $like: 'metadata_note:'\n                                  },\n                                  'data.data.metadata.data.note': {\n                                    $like: searchText\n                                  }\n                                },{\n                                  'data.data.metadata.type': {\n                                    $like: 'metadata_tags:'\n                                  },\n                                  'data.data.metadata.data.tags': {\n                                    $contains: searchText\n                                  }\n                                }]\n                                // 'data.data.owner': this.props.state.OwnerSecondExternalIdentityNode.data.InternalUserNode.data.uuid\n                              },\n                            }\n                          }\n                        },\n                        \n                        // Group matches by targetTypes, and by targetType.groupByField \n                        {\n                          matchActionType: 'reduce_search:Qmlfjsdlsf',\n                          dataForAction: {\n                            type: 'reduce_request:Qmsf89h923sf',\n                            data: {\n                              type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                              data: {\n                                code: `(()=>{\n                                  return new Promise(async (resolve,reject)=>{\n                                    \n                                    let requestCache = INPUT.data.requestCache; \n                                    // await universe.getRequestCache();\n                                    \n                                    let lastRequestResults;\n                                    try {\n                                      lastRequestResults = requestCache.keyvalue.request1; // 1st/2nd request (depending on authtoken)\n                                    }catch(err){\n                                      console.error(err);\n                                    }\n                                    \n                                    lastRequestResults = lastRequestResults || [];\n                                    \n                                    console.log('lastRequestResults length:', lastRequestResults.length);\n                                    \n                                    // for each shared metadata node \n                                    //   group all of the types together \n                                    //   find matching types, get the groupBy field for the type \n                                    //     find same type, and same groupBy field \n                                    //     put all of the groupBy into a list, with the type/groupBy result as the key\n                                    //     - summarize certain fields by metadata type, rating, etc. (where not all data is needed for display) \n                                    let uuids = {};\n                                    let nodes = [];\n                                    lastRequestResults.forEach(resultNode=>{\n                                      let uuid;\n                                      let target = resultNode.data.data.target;\n                                      switch(target.type.split(':')[0]){\n                                        case 'metadata_target_email': \n                                          uuid  = [target.type, target.data.email].join('|');\n                                          break;\n                                        case 'metadata_target_url': \n                                          uuid  = [target.type, target.data.url].join('|');\n                                          break;\n                                        default:\n                                          console.log('unexpected type');\n                                          return;\n                                      }\n                                      console.log('--UUID--', uuid);\n                                      if(!uuids[uuid]){\n                                        // uses the \"first\" target as the base! \n                                        uuids[uuid] = {\n                                          type: target.type,\n                                          data: {\n                                            target,\n                                          },\n                                          nodes: []\n                                        }\n                                        nodes.push(uuid);\n                                      }\n                                      uuids[uuid].nodes.push(resultNode);\n                                      // nodes.push(resultNode);\n                                    })\n                                    \n                                    nodes = nodes.map(uuid=>{\n                                      return uuids[uuid];\n                                    });\n                                    \n                                    // return inputNode;\n                                    return resolve({\n                                      type: 'list_of_nodes:0.0.1:local:3289f2',\n                                      data: nodes\n                                    });\n                                    \n                                  });\n                                })()`\n                              }\n                            },\n                            \n                          }\n                        },\n                        \n                        // TODO: fetch all matches for each (stars, notes, etc.) \n                        // - currently only returning first-order matches (need find, summarize, findAll, return) \n                        \n                      ]\n                      \n                    }\n                  }\n                }\n              }\n            });\n            \n            // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n            let nodes = response.data.actionResponses[2].data;\n            \n            console.log('Metadata results', nodes);\n            \n            this.setState({\n              metadataResults: nodes,\n              fetchingMetadata: false\n            }, resolve);\n            \n          });\n          \n        }\n        \n        @autobind\n        fetchGroups(){\n          \n          return new Promise(async (resolve,reject)=>{\n            \n            this.setState({\n              fetchingGroups: true\n            });\n            \n            let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n              type: 'standard_capability_action:0.0.1:local:298j291bs',\n              data: {\n                action: 'send',\n                options: {\n                  ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                  RequestNode: {\n                    type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                    data: {\n                      actions: [\n                        {\n                          matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                          dataForAction: {\n                            type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                            data: {\n                              matchFunctionNode: {\n                                // query here!\n                                // action_pointer:0.0.1:local:238972ncr\n                                type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                data: {\n                                  code: `(()=>{\n                                    // Action \n                                    // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                    \n                                    let inputNode = INPUT.data.inputNode;\n                                    \n                                    if(inputNode.nodeId){\n                                      return false;\n                                    }\n                                    \n                                    if(inputNode.type.split(':')[0] != 'group_for_sharing'){\n                                      return false;\n                                    }\n                                    \n                                    return inputNode;\n                                    \n                                  })()`\n                                }\n                              },\n                              // expected/allowed schemas for return \n                              // outputSchemas: [\n                              //   'query_result:0.0.1:local:32490usfj23o23f',\n                              //   'internal_error_output:0.0.1:local:32948x2u3cno2c'\n                              // ]\n                            }\n                          }\n                        }\n                      ]\n                      \n                    }\n                  }\n                }\n              }\n            });\n            \n            // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n            let nodes = response.data.actionResponses[0].data;\n            \n            this.setState({\n              groups: nodes,\n              fetchingGroups: false\n            }, resolve);\n            \n          });\n          \n        }\n        \n        @autobind\n        fetchExternalConnections(){\n          \n          return new Promise(async (resolve,reject)=>{\n            \n            this.setState({\n              fetchingConnections: true\n            });\n            \n            let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n              type: 'standard_capability_action:0.0.1:local:298j291bs',\n              data: {\n                action: 'send',\n                options: {\n                  ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                  RequestNode: {\n                    type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                    data: {\n                      actions: [\n                        {\n                          matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                          dataForAction: {\n                            type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                            data: {\n                              matchFunctionNode: {\n                                // query here!\n                                // action_pointer:0.0.1:local:238972ncr\n                                type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                data: {\n                                  code: `(()=>{\n                                    // Action \n                                    // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                    \n                                    let inputNode = INPUT.data.inputNode;\n                                    \n                                    if(inputNode.nodeId){\n                                      return false;\n                                    }\n                                    \n                                    if(inputNode.type.split(':')[0] != 'external_identity'){\n                                      return false;\n                                    }\n                                    \n                                    return inputNode;\n                                    \n                                  })()`\n                                }\n                              },\n                              // expected/allowed schemas for return \n                              // outputSchemas: [\n                              //   'query_result:0.0.1:local:32490usfj23o23f',\n                              //   'internal_error_output:0.0.1:local:32948x2u3cno2c'\n                              // ]\n                            }\n                          }\n                        }\n                      ]\n                      \n                    }\n                  }\n                }\n              }\n            });\n            \n            // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n            console.log('fetchExternalConnections Response:', response);\n            \n            let nodes = response.data.actionResponses[0].data;\n            \n            this.setState({\n              allExternalConnections: nodes,\n              fetchingConnections: false\n            }, this.updateConnectionGroups);\n            \n            resolve(nodes);\n            \n            \n          });\n          \n        }\n        \n        @autobind\n        fetchMine(){\n          // shared_node\n          // \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n              \n              this.setState({\n                fetchingMine: true\n              })\n              \n              // Get my identity \n              // - should use \"signer\" instead? \n              // - or just look for ones where signer=author \n              let author = this.props.state.OwnerSecondExternalIdentityNode.data.identity; // \"idtest:nick\"\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          \n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                      \n                          // Part 1/3\n                          // Fetch MY threads (where I am the author) \n                          // - of a \"post:Qmfdlsj\" type \n                          // - use the returned thread_ref to find ALL the related (by me or not) Posts (and other data too, I suppose) \n                          {\n                            matchActionType: 'search_shared_data:Qmksdjhfwekjhdds24f',\n                            dataForAction: {\n                              // type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              type: 'shared_data_request:Qmsdfljsdj',\n                              data: {\n                                // filter on the ENTIRE shared_node (NOT just on the shared_node data) \n                                dataFilter: {\n                                  'data.signer': author,\n                                  'data.data.author' : author\n                                },\n                                // matchFunctionNode: {\n                                //   // query here!\n                                //   // action_pointer:0.0.1:local:238972ncr\n                                //   type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                //   data: {\n                                //     code: `(()=>{\n                                //       // Part 1/2\n                                      \n                                //       let inputNode = INPUT.data.inputNode;\n                                      \n                                //       // threads I participated in \n                                      \n                                //       if(inputNode.data.signer != \"${author}\"){\n                                //         return false;\n                                //       }\n                                //       // type:\"post:..\".data = {message, author, in_reply_to, thread_ref}\n                                //       if(inputNode.data.data.author != \"${author}\"){\n                                //         return false;\n                                //       }\n                                      \n                                //       // return whole object (reduced later to thread_refs) \n                                //       return inputNode;\n                                      \n                                //     })()`\n                                //   }\n                                // },\n                                // expected/allowed schemas for return \n                                // outputSchemas: [\n                                //   'query_result:0.0.1:local:32490usfj23o23f',\n                                //   'internal_error_output:0.0.1:local:32948x2u3cno2c'\n                                // ]\n                              }\n                            }\n                          },\n                          \n                          // Part 2/3 \n                          // - reduce above (from requestCache) to thread_ref, and use in next step! \n                          {\n                            matchActionType: 'reduce_search:Qmlfjsdlsf',\n                            dataForAction: {\n                              // type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              type: 'reduce_request:Qmsf89h923sf',\n                              data: {\n                              \n                                type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                data: {\n                                  code: `(()=>{\n                                    return new Promise(async (resolve,reject)=>{\n                                      // Part 2/3\n                                      // Reduce for next step \n                                      // - setting requestVariables too \n                                      \n                                      let requestCache = INPUT.data.requestCache; \n                                      // await universe.getRequestCache();\n                                      \n                                      let lastRequestResults;\n                                      try {\n                                        lastRequestResults = requestCache.keyvalue.request1; // 1st/2nd request (depending on authtoken)\n                                      }catch(err){\n                                        console.error(err);\n                                      }\n                                      \n                                      lastRequestResults = lastRequestResults || [];\n                                      \n                                      let threadRefs = lastRequestResults.map(req=>{\n                                        return req.data.data.thread_ref;\n                                      });\n                                      \n                                      \n                                      // return inputNode;\n                                      return resolve({\n                                        type: 'array_of_refs:Qmdslfjsdlf22',\n                                        data: {\n                                          refs: threadRefs\n                                        }\n                                      });\n                                      \n                                    });\n                                  })()`\n                                }\n                              },\n                              \n                            }\n                          },\n                          \n                          \n                          // Part 3/3\n                          // Fetch data for thread_refs (includes My results too) \n                          // - of a \"post:Qmfdlsj\" type \n                          // - use the returned thread_ref to find ALL the related (by me or not) Posts (and other data too, I suppose) \n                          {\n                            matchActionType: 'search_shared_data:Qmksdjhfwekjhdds24f',\n                            dataForAction: {\n                              // type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              type: 'shared_data_request:Qmsdfljsdj',\n                              data: {\n                                dataFilter: {\n                                  'data.data.thread_ref': {\n                                    // $in: \"[[$$test.test1$$]]\",\n                                    $in: \"[[$$(INPUT.data.requestCache.keyvalue.request2.data.refs)$$]]\"\n                                  }\n                                },\n                                // matchFunctionNode: {\n                                //   // query here!\n                                //   // action_pointer:0.0.1:local:238972ncr\n                                //   type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                //   data: {\n                                //     code: `(()=>{\n                                //       // Part 3/3\n                                      \n                                //       // return all results that match thread_ref! \n                                //       // - me, plus anyone else! \n                                      \n                                //       let inputNode = INPUT.data.inputNode;\n                                      \n                                //       let requestCache = INPUT.data.requestCache; \n                                      \n                                //       let threadRefResultNode;\n                                //       try {\n                                //         threadRefResultNode = requestCache.keyvalue.request1; // 2nd/3rd request (depending on authtoken)\n                                //       }catch(err){\n                                //         console.error(err);\n                                //       }\n                                      \n                                //       // console.log('threadRefResultNode',threadRefResultNode);\n                                      \n                                //       let threadRefs = threadRefResultNode.data.refs;\n                                      \n                                //       if(threadRefs.indexOf(inputNode.data.data.thread_ref) === -1){\n                                //         return false;\n                                //       }\n                                      \n              \n                                //       return inputNode;\n                                      \n                                //     })()`\n                                //   }\n                                // },\n                                // expected/allowed schemas for return \n                                // outputSchemas: [\n                                //   'query_result:0.0.1:local:32490usfj23o23f',\n                                //   'internal_error_output:0.0.1:local:32948x2u3cno2c'\n                                // ]\n                              }\n                            }\n                          },\n                          \n                          // TODO: clear results I dont care about (map->reduce...kill all the map results!) \n                          \n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              let nodes = response.data.actionResponses[3].data;\n              \n              // Create trees from nodes (in_reply_to) \n              // - get all of my unique Posts \n              let myPosts = universe.lodash.uniq(nodes.filter(node=>{\n                // filter \n                return node.data.data.author == author;\n              }), node=>{\n                // uniq filter \n                return node.data._id; // unique id of source (identity:address) \n              }).sort((a,b)=>{\n                // newest at top \n                return a.data.data.createdAt < b.data.data.createdAt;\n              });\n              // function getChildren(nodes){\n              //   nodes.map(node=>{\n                  \n              //   })\n              // }\n              // getChildren(nodes);\n              \n              console.log('myPosts', myPosts);\n              \n              // let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                notes: nodes,\n                myPosts,\n                fetchingMine: false\n              })\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              this.setState({\n                fetchingMine: false\n              })\n              \n            }\n            \n          });\n          \n          \n        }\n        \n        @autobind\n        fetchFromRemoteForIdentity(props){\n          // fetching data from a remote (syndicated-to) Second \n          // - data for a Single person's thread \n          \n          this.setState({\n            fetchingRemote: true\n          });\n          \n          props = props || this.props;\n          \n          console.log('fetchFromRemoteForIdentity.New Props', props);\n          \n          let viewIdentity = this.state.viewIdentity;\n          if(!viewIdentity.length){\n            console.log('no identity to search for yet');\n            return false;\n          }\n          \n          let searchIdentity = this.state.searchIdentity;\n          if(!searchIdentity.length){\n            console.log('no search identity to search for yet');\n            return false;\n          }\n          \n          // Get search identity exernal_identity (for searching) \n          \n          viewIdentity = [this.state.viewIdentityType, viewIdentity].join(':');\n          \n          this.setState({\n            viewingIdentity: viewIdentity\n          });\n          \n          // Get who to search (where data was syndicated to) \n          \n          \n          \n          \n          // \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n              \n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          \n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                          \n                          {\n                            matchActionType: 'remote_run_action_sequence_authorized:Qm329f83289hsf',\n                            dataForAction: {\n                              type: 'remote_action_sequence_input:Qmf8329j29388923h8f22f',\n                              data: {\n                                // who to search (by identity, token) \n                                // action_sequence array \n                                \n                                identity: searchIdentity,\n                                // internalId: ExternalIdentityNode._id,\n                                // publicKey: ExternalIdentityNode.data.publicKey,\n                                \n                                actions: [\n                                  \n                                  // identify_via_token is added automatically to the beginning of the sequence\n                                  // {\n                                  //   matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                                  //   dataForAction: {\n                                  //     type: 'string:...',\n                                  //     data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                                  //   }\n                                  // },\n                              \n                                  // Part 1/3\n                                  // Fetch MY threads (where I am the author) \n                                  // - of a \"post:Qmfdlsj\" type \n                                  // - use the returned thread_ref to find ALL the related (by me or not) Posts (and other data too, I suppose) \n                                  {\n                                    matchActionType: 'search_shared_data:Qmksdjhfwekjhdds24f',\n                                    dataForAction: {\n                                      // type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                                      type: 'shared_data_request:Qmsdfljsdj',\n                                      data: {\n                                        // filter on the ENTIRE shared_node (NOT just on the shared_node data) \n                                        dataFilter: {\n                                          'data.signer': viewIdentity,\n                                          'data.data.author' : viewIdentity\n                                        },\n                                      }\n                                    }\n                                  },\n                                  \n                                  // Part 2/3 \n                                  // - reduce above (from requestCache) to thread_ref, and use in next step! \n                                  {\n                                    matchActionType: 'reduce_search:Qmlfjsdlsf',\n                                    dataForAction: {\n                                      // type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                                      type: 'reduce_request:Qmsf89h923sf',\n                                      data: {\n                                      \n                                        type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                        data: {\n                                          code: `(()=>{\n                                            return new Promise(async (resolve,reject)=>{\n                                              // Part 2/3\n                                              // Reduce for next step \n                                              // - setting requestVariables too \n                                              \n                                              let requestCache = INPUT.data.requestCache; \n                                              // await universe.getRequestCache();\n                                              \n                                              let lastRequestResults;\n                                              try {\n                                                lastRequestResults = requestCache.keyvalue.request1; // 1st/2nd request (depending on authtoken)\n                                              }catch(err){\n                                                console.error(err);\n                                              }\n                                              \n                                              lastRequestResults = lastRequestResults || [];\n                                              \n                                              let threadRefs = lastRequestResults.map(req=>{\n                                                return req.data.data.thread_ref;\n                                              });\n                                              \n                                              \n                                              // return inputNode;\n                                              return resolve({\n                                                type: 'array_of_refs:Qmdslfjsdlf22',\n                                                data: {\n                                                  refs: threadRefs\n                                                }\n                                              });\n                                              \n                                            });\n                                          })()`\n                                        }\n                                      },\n                                      \n                                    }\n                                  },\n                                  \n                                  \n                                  // Part 3/3\n                                  // Fetch data for thread_refs (includes My results too) \n                                  // - of a \"post:Qmfdlsj\" type \n                                  // - use the returned thread_ref to find ALL the related (by me or not) Posts (and other data too, I suppose) \n                                  {\n                                    matchActionType: 'search_shared_data:Qmksdjhfwekjhdds24f',\n                                    dataForAction: {\n                                      // type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                                      type: 'shared_data_request:Qmsdfljsdj',\n                                      data: {\n                                        dataFilter: {\n                                          'data.data.thread_ref': {\n                                            // $in: \"[[$$test.test1$$]]\",\n                                            $in: \"[[$$(INPUT.data.requestCache.keyvalue.request2.data.refs)$$]]\"\n                                          }\n                                        },\n                                      }\n                                    }\n                                  },\n                                  \n                                  // TODO: clear results I dont care about (map->reduce...kill all the map results!) \n                                  \n                                ]\n                                \n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              console.log('FullExternalResponse', response);\n              \n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              let nodes = response.data.actionResponses[1].data.actionResponses[3].data;\n              \n              console.log('Nodes:', nodes);\n              \n              // Create trees from nodes (in_reply_to) \n              // - get all of my unique Posts \n              let myPosts = universe.lodash.uniq(nodes.filter(node=>{\n                // filter \n                return node.data.data.author == viewIdentity;\n              }), node=>{\n                // uniq filter \n                return node.data._id; // unique id of source (identity:address) \n              }).sort((a,b)=>{\n                // newest at top \n                return a.data.data.createdAt < b.data.data.createdAt;\n              });\n              \n              \n              this.setState({\n                myPosts,\n                // fetchingMine: false\n              })\n              \n              \n            } catch(err){\n              console.error('Failed getting local nodes', err);\n            }\n            \n              \n            this.setState({\n              fetchingRemote: false\n            });\n            \n          \n          });\n          \n        }\n        \n        @autobind\n        handleSearch(){\n          console.log('searching');\n          \n          this.fetchMetadata();\n          \n          // this.setState({\n          //   isSearching: true\n          // });\n          \n        }\n        \n        @autobind\n        handleSearchKeyDown(e){\n        \n          if(e.key && e.key.toLowerCase() == 'enter'){\n            \n            this.handleSearch();\n            \n          } \n        }\n        \n        @autobind\n        async handleCreateMetadata(){\n          \n          console.log('handleCreateMetadata');\n          \n          try {\n              \n            // Target \n            // - choose correct type \n            \n            // Get Target and Metadata types \n            let targetType = this.state.possibleTargetTypes.find(t=>{\n              return t[1] == this.state.targetType;\n            });\n            \n            let metadataType = this.state.possibleMetadataTypes.find(t=>{\n              return t[1] == this.state.metadataType;\n            });\n            \n            console.log('targetType', targetType);\n            console.log('metadataType', metadataType);\n            \n            // Create Target and Metadata nodes \n            let targetNode = {\n              type: targetType[1],\n              data: this.state.targetData\n              // {\n              //   email: 'nick@getasecond.com' //this.props.state.OwnerSecondExternalIdentityNode.data.InternalUserNode.data.uuid\n              // }\n            };\n            \n            \n            // Process data inputs (convert stuff if necessary, string->array)\n            // - depends on the type (should have translate/convert information) \n            let metadataData = JSON.parse(JSON.stringify(this.state.metadataData));\n            switch(metadataType[1].split(':')[0]){\n              case 'metadata_tags':\n                metadataData.tags = universe.lodash.compact(universe.lodash.uniq(metadataData.tags.split(',').map(t=>t.trim())));\n                break;\n                \n              case 'metadata_stars_1_5':\n                metadataData.rating = parseInt(metadataData.rating, 10);\n                break;\n                \n              default:\n                // use whatever was input\n                break;\n            }\n            \n            let metadataNode = {\n              type: metadataType[1],\n              data: metadataData\n              // data: {\n              //   note: 'testing searchable note for nick test test'\n              // }\n            };\n            \n            \n            let permissionsPrivate = this.state.createPrivate ? true:false;\n            \n            let sharedNode = {\n              type: 'metadata:Qmfj3292h39hsf',\n              data: {\n                target: targetNode,\n                metadata: metadataNode,\n                owner: this.props.state.OwnerSecondExternalIdentityNode.data.InternalUserNode.data.uuid,\n                createdAt: Date.now(), // utc milliseconds since epoch \n              }\n            }\n            \n            // should be OK to contain a code template \n            let permissionsNode = {\n              type: 'syndication_permissions:Qmsdfkjsl2fj9vxc',\n              data: {\n                rules: []\n              }\n            };\n            if(permissionsPrivate){\n              permissionsNode.data.rules.push({\n                type: 'internal_private:Qm3289f0h23',\n                data: true\n              });\n            }\n            \n            let syndicateToNode = null;\n            \n            console.log('sharedNode:',sharedNode);\n            \n            \n            let saveSharedNode = await this.createNodeOnSecond(sharedNode, permissionsNode, syndicateToNode);\n            \n            console.log('saveSharedNode',saveSharedNode);\n            \n          }catch(err){\n            console.error(err);\n          }\n          \n          // // // refetch \n          // // this.fetchMine();\n          \n          \n        }\n        \n        @autobind\n        handleUpdateMetadataOnSecond(sharedNode){\n          console.log('sharedNode to update:', sharedNode);\n          \n          sharedNode.data.data.target.data.url = WINDOW.prompt('new',sharedNode.data.data.target.data.url);\n          \n          this.updateNodeOnSecond(sharedNode,{},{});\n        }\n        \n        @autobind\n        createNodeOnSecond(sharedNode, permissionsNode, syndicateToNode){\n          return new Promise(async (resolve, reject) => {\n            \n            console.log('NewNode:', sharedNode);\n            \n            this.setState({\n              isCreating: true\n            })\n                \n            // Make request to save Node on remote \n            try {\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                      \n                          {\n                            matchActionType: 'create_and_syndicate:Qmwlekjfwl',\n                            dataForAction: {\n                              type: 'create_and_syndicate_data:Qmskfjwoesjf',\n                              data: {\n                                sharedNode, // should include author=Second \n                                permissionsNode, // who can access this, get syndicated also \n                                syndicateToNode // where to syndicate this sharedNode  \n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('create_and_syndicate response:', response);\n              \n              // get the created node \n              let savedNode = response.data.actionResponses[1];\n              \n              // console.log('Saved Node:', savedNode);\n            \n              try {\n                universe.EE.emit('nodes-modified', '');\n              }catch(err){\n                console.error(err);\n              }\n                \n              this.setState({\n                isCreating: false\n              })\n              \n              return resolve(savedNode);\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              // alert('Failed');\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            }\n            \n            this.setState({\n              isCreating: false\n            })\n            \n          })\n        }\n        \n        @autobind\n        updateNodeOnSecond(sharedNode, permissionsNode, syndicateToNode){\n          return new Promise(async (resolve, reject) => {\n            \n            console.log('UpdateNode:', sharedNode);\n            \n            this.setState({\n              isCreating: true\n            })\n                \n            // Make request to save Node on remote \n            try {\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                      \n                          {\n                            matchActionType: 'update_and_syndicate:Qmf3289h2323',\n                            dataForAction: {\n                              type: 'update_and_syndicate_data:Qmskfjwoesjf',\n                              data: {\n                                sharedNode, // should include author=Second \n                                permissionsNode, // who can access this, get syndicated also \n                                syndicateToNode // where to syndicate this sharedNode  \n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('update_and_syndicate response:', response);\n              \n              // get the created node \n              let savedNode = response.data.actionResponses[1];\n              \n              // console.log('Saved Node:', savedNode);\n            \n              try {\n                universe.EE.emit('nodes-modified', '');\n              }catch(err){\n                console.error(err);\n              }\n                \n              this.setState({\n                isCreating: false\n              })\n              \n              return resolve(savedNode);\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              // alert('Failed');\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            }\n            \n            this.setState({\n              isCreating: false\n            })\n            \n          })\n        }\n        \n        @autobind\n        handleUpdatePost(){\n        }\n        \n        @autobind\n        handleRemovePost(){\n        }\n        \n        @autobind\n        handleUpdatePostText(e){\n          this.setState({\n            postText: e.target.value\n          });\n        }\n        \n        @autobind\n        handleUpdateSyndicationSearchTarget(e){\n          // TODO: add multiple groups, identities, deny rules, etc. ! \n          this.setState({\n            searchIdentity: e.target.value\n          });\n        }\n        \n        @autobind\n        handleUpdateViewIdentityType(e){\n          // TODO: add multiple groups, identities, deny rules, etc. ! \n          this.setState({\n            viewIdentityType: e.target.value\n          });\n        }\n        \n        \n        @autobind\n        handleUpdatePostGroup(e){\n          // TODO: add multiple groups, identities, deny rules, etc. ! \n          this.setState({\n            postGroupNodeId: e.target.value\n          });\n        }\n        \n        @autobind\n        handleUpdateTargetType(e){\n          // TODO: add multiple groups, identities, deny rules, etc. ! \n          this.setState({\n            targetType: e.target.value\n          });\n        }\n        \n        @autobind\n        handleUpdateMetadataType(e){\n          // TODO: add multiple groups, identities, deny rules, etc. ! \n          this.setState({\n            metadataType: e.target.value\n          });\n        }\n        \n        @autobind\n        handleUpdateTargetData(field, value){\n          let targetData = this.state.targetData;\n          targetData[field] = value;\n          this.setState({\n            targetData\n          });\n        }\n        \n        @autobind\n        handleUpdateMetadataData(field, value){\n          let metadataData = this.state.metadataData;\n          metadataData[field] = value;\n          this.setState({\n            metadataData\n          });\n        }\n        \n        @autobind\n        renderResults(){\n          return this.state.metadataResults.map((parentNode,idx)=>{\n            \n            // parentNode is the result node from the \"reduce_result\" request \n            // - contains the target (groupBy'd), and nodes for the actual metadata \n            \n            // let node = parentNode.data;\n            console.log('parentNode:', parentNode);\n            \n            let target = parentNode.data.target;\n            \n            // get firstShared for editing sharedNode (temporary)\n            let firstShared = parentNode.nodes[0];\n            \n            // types of overlays \n            let metadataTypes = {};\n            metadataTypes.notes = parentNode.nodes.filter(n=>{return n.data.data.metadata.type.indexOf('metadata_note') > -1});\n            metadataTypes.tags = parentNode.nodes.filter(n=>{return n.data.data.metadata.type.indexOf('metadata_tags') > -1});\n            metadataTypes.stars = parentNode.nodes.filter(n=>{return n.data.data.metadata.type.indexOf('metadata_stars_1_5') > -1});\n            \n            function getSum(total, num) {\n              return parseInt(total,10) + parseInt(num,10);\n            }\n            \n            return (\n              <div key={parentNode._id} style={{paddingBottom:\"8px\", width:\"380px\"}}>\n                <div className=\"box\" onClick={e=>this.handleUpdateMetadataOnSecond(firstShared)}>\n                  <div>\n                    {\n                      (()=>{\n                        let name = 'unknown';\n                        switch(target.type.split(':')[0]){\n                          case 'metadata_target_email':\n                            name = target.data.email;\n                            break;\n                          case 'metadata_target_url':\n                            name = target.data.url;\n                            break;\n                          default:\n                            break;\n                        }\n                        return (\n                          <h3 className=\"title is-5\">\n                            {name}\n                          </h3>\n                        )\n                      })()\n                    }\n                  </div>\n                  \n                  {\n                    metadataTypes.notes.length ?\n                    <div>\n                      {\n                        metadataTypes.notes.length\n                      } notes\n                    </div>\n                    :''\n                  }\n                  \n                  {\n                    metadataTypes.tags.length ?\n                    <div className=\"tags\">\n                      {\n                        universe.lodash.uniq(universe.lodash.flatten(metadataTypes.tags.map(t=>t.data.data.metadata.data.tags))).map(t=>(\n                          <span key={t} className=\"tag\">\n                            {t}\n                          </span>\n                        ))\n                      }\n                    </div>\n                    :''\n                  }\n                  \n                  {\n                    metadataTypes.stars.length ?\n                    <div>\n                      {\n                        metadataTypes.stars.length\n                      } ratings ({metadataTypes.stars.map(starNode=>starNode.data.data.metadata.data.rating).reduce(getSum) / metadataTypes.stars.length} avg.)\n                    </div>\n                    :''\n                  }\n                  \n                  <hr />\n                  <div>\n                    <small>{\n                      universe.lodash.uniq(parentNode.nodes.map(n=>n.data.data.owner)).join(', ')\n                    }</small>\n                  </div>\n                  \n                </div>\n              </div>\n            )\n          })\n        }\n        \n        render(){\n          \n          let tabsMain = [\n            ['all','All'],\n            ['url', 'URLs'],\n            ['email', 'Emails'],\n            ['file', 'Files'],\n          ];\n          \n          \n          return (\n        \n            <div className=\"container\">\n              <br />\n              <div className=\"columns\">\n                \n                <div className=\"column is-8\">\n                  \n                  <div className=\"field has-addons\">\n                    <div className=\"control is-expanded\">\n                      <input className=\"input\" value={this.state.searchText} onChange={e=>this.setState({searchText:e.target.value})} placeholder=\"Search Metadata Targets\" onKeyDown={this.handleSearchKeyDown} />\n                    </div>\n                    <div className=\"control\">\n                      <button className={\"button is-success \" + (this.state.fetchingMetadata ? 'is-loading':'')} onClick={this.handleSearch}>Search</button>\n                    </div>\n                    \n                  </div>\n                  \n                  \n                </div>\n                \n              </div>\n              \n              <div className=\"columns\">\n                \n                <div className=\"column is-6\">\n                        \n                    <div className=\"tabs\">\n                      <ul>\n                        {\n                          tabsMain.map(tab=>(\n                            <li key={tab[0]}\n                              onClick={e=>this.setState({tabMain:tab[0]})}\n                              className={(this.state.tabMain == tab[0]) ? 'is-active':''}\n                              ><a>{tab[1]}</a></li>\n                          ))\n                        }\n                      </ul>\n                    </div>\n                    \n                    {/* render results */}\n                    \n                    {\n                      this.renderResults()\n                    }\n                  \n                  \n                </div>\n                  \n              \n                <div className=\"column is-6\">\n              \n                  <h3 className=\"title is-3\">\n                    Create Metadata Overlay\n                  </h3>\n                  \n                  <br />\n                  \n                  <div className=\"field\">\n                    <div className=\"control\">\n                      <div className=\"select\">\n                        <select onChange={this.handleUpdateTargetType} value={this.state.targetType}>\n                          <option>Target Type:</option>\n                          {\n                            this.state.possibleTargetTypes.map(possibleType=>(\n                              <option key={possibleType[1]} value={possibleType[1]}>{possibleType[0]}</option>\n                            ))\n                          }\n                          {\n                            (!this.state.possibleTargetTypes.length && this.state.fetchingPossibleTargetTypes) ?\n                            <option>Loading types</option>\n                            :''\n                          }\n                        </select>\n                      </div>\n                    </div>\n                  </div>\n                  \n                  {/* target data input */}\n                  <div className=\"field\">\n                  \n                    {\n                      (this.state.targetType && this.state.targetType.indexOf('metadata_target_email') === 0) ?\n                      <div className=\"control\">\n                        <input className=\"input\" value={this.state.targetData.email} onChange={e=>this.handleUpdateTargetData('email',e.target.value)} placeholder=\"Email\" />\n                      </div>\n                      :''\n                    }\n                    \n                    {\n                      (this.state.targetType && this.state.targetType.indexOf('metadata_target_url') === 0) ?\n                      <div className=\"control\">\n                        <input className=\"input\" value={this.state.targetData.url} onChange={e=>this.handleUpdateTargetData('url',e.target.value)} placeholder=\"URL\" />\n                      </div>\n                      :''\n                    }\n                    \n                  </div>\n                  \n                  \n                  \n                  \n                  <div className=\"field\">\n                    <div className=\"control\">\n                      <div className=\"select\">\n                        <select onChange={this.handleUpdateMetadataType} value={this.state.metadataType}>\n                          <option>Metadata Type:</option>\n                          {\n                            this.state.possibleMetadataTypes.map(possibleType=>(\n                              <option key={possibleType[1]} value={possibleType[1]}>{possibleType[0]}</option>\n                            ))\n                          }\n                          {\n                            (!this.state.possibleMetadataTypes.length && this.state.fetchingPossibleTargetTypes) ?\n                            <option>Loading types</option>\n                            :''\n                          }\n                        </select>\n                      </div>\n                    </div>\n                  </div>\n                  {/* metadata data input */}\n                  <div className=\"field\">\n                  \n                    {\n                      (this.state.metadataType && this.state.metadataType.indexOf('metadata_note') === 0) ?\n                      <div className=\"control\">\n                        <input className=\"input\" value={this.state.metadataData.note} onChange={e=>this.handleUpdateMetadataData('note',e.target.value)} placeholder=\"Note\" />\n                      </div>\n                      :''\n                    }\n                    \n                    {\n                      (this.state.metadataType && this.state.metadataType.indexOf('metadata_tags') === 0) ?\n                      <div className=\"control\">\n                        <input className=\"input\" value={this.state.metadataData.url} onChange={e=>this.handleUpdateMetadataData('tags',e.target.value)} placeholder=\"Tags, comma-separated\" />\n                      </div>\n                      :''\n                    }\n                    \n                    {\n                      (this.state.metadataType && this.state.metadataType.indexOf('metadata_stars_1_5') === 0) ?\n                      <div className=\"control\">\n                        <input type=\"number\" className=\"input\" value={this.state.metadataData.rating} onChange={e=>this.handleUpdateMetadataData('rating',e.target.value)} placeholder=\"Stars, 1-5\" />\n                      </div>\n                      :''\n                    }\n                    \n                  </div>\n                  \n                                    \n                  <div className=\"field\">\n                    <div className=\"control\">\n                      <label className=\"checkbox\">\n                        <input type=\"checkbox\" checked={this.state.createPrivate} onChange={e=>this.setState({createPrivate:!this.state.createPrivate})} />\n                        Private\n                      </label>\n                    </div>\n                  </div>\n                         \n                  <div className=\"field\">\n                    <div className=\"control\">\n                      <button className={\"button is-info \" + (this.state.isCreating ? 'is-loading':'')} onClick={this.handleCreateMetadata}>Create</button>\n                    </div>\n                  </div>\n                \n                \n                </div>\n              \n                \n              \n              </div>\n              \n            </div>\n            \n            \n          )\n        }\n      }\n      \n      mycomponent = universe.ReactGlobalState(mycomponent);\n      mycomponent = universe.ReactHelpers(mycomponent);\n      \n      const styles = {\n        deleteIcon: {\n          position: 'absolute',\n          top: '0px',\n          right: '-24px',\n          cursor: 'pointer'\n        }\n      }\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: mycomponent\n      });\n      \n    }catch(err){\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()",
    "internalId": "MainHomeComponent"
  }
}