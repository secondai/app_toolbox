{
  "type": "react_component:0.0.1:local:98912hd89",
  "name": "MainGroupsComponent",
  "data": {
    "author": "-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCcuXovU+RZy85KMqLakYSH1mdV\nWdpEUtgcXUyGyU5hVeTO7BkV/kxeC2upcxOwNnrBOdsvHI3nrrILgt90/hCSHKzx\nhOFLREorGoKtSEHxI7/SnzzlWtV3gT/IP5GVHIyvuJBx3hCti0dH55DZG8iMGZ2y\ncGpV73Dez3hHmeBh6wIDAQAB\n-----END PUBLIC KEY-----",
    "version": "1",
    "key": "f09e5cae-613e-48bd-bb25-184647d96f76",
    "code": "(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      const AceEditor = universe.AceEditor;\n      const ReactResizeDetector = universe.ReactResizeDetector;\n      const RecreateChildOnPropsChange = universe.RecreateChildOnPropsChange;\n      \n      const Link = universe.ReactRouterDomLink;\n      \n      const Router = universe.ReactRouterDomRouter;\n      const Route = universe.ReactRouterDomRoute;\n      const Switch = universe.ReactRouterDomSwitch;\n      \n      class EmbeddedComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              embeddedComponenthere\n            </div>\n          )\n        }\n      }\n      \n      class ErrorComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        render(){\n          return (\n            <div>\n              ErrorLoading\n            </div>\n          )\n        }\n      }\n      \n      class mycomponent extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {\n            groups: [],\n            groupConnections: [],\n            allExternalConnections: []\n          }\n        }\n        \n        componentDidMount(){\n            \n          this.startup();\n            \n        }\n        \n        @autobind\n        async startup(){\n          await this.fetchGroups();\n          await this.fetchExternalConnections();\n        }\n        \n        @autobind\n        fetchGroups(){\n          \n          return new Promise(async (resolve,reject)=>{\n            \n            this.setState({\n              fetchingGroups: true\n            });\n            \n            let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n              type: 'standard_capability_action:0.0.1:local:298j291bs',\n              data: {\n                action: 'send',\n                options: {\n                  ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                  RequestNode: {\n                    type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                    data: {\n                      actions: [\n                        {\n                          matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                          dataForAction: {\n                            type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                            data: {\n                              matchFunctionNode: {\n                                // query here!\n                                // action_pointer:0.0.1:local:238972ncr\n                                type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                data: {\n                                  code: `(()=>{\n                                    // Action \n                                    // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                    \n                                    let inputNode = INPUT.data.inputNode;\n                                    \n                                    if(inputNode.nodeId){\n                                      return false;\n                                    }\n                                    \n                                    if(inputNode.type.split(':')[0] != 'group_for_sharing'){\n                                      return false;\n                                    }\n                                    \n                                    return inputNode;\n                                    \n                                  })()`\n                                }\n                              },\n                              // expected/allowed schemas for return \n                              // outputSchemas: [\n                              //   'query_result:0.0.1:local:32490usfj23o23f',\n                              //   'internal_error_output:0.0.1:local:32948x2u3cno2c'\n                              // ]\n                            }\n                          }\n                        }\n                      ]\n                      \n                    }\n                  }\n                }\n              }\n            });\n            \n            // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n            let nodes = response.data.actionResponses[0].data;\n            \n            this.setState({\n              groups: nodes,\n              fetchingGroups: false\n            }, resolve);\n            \n          });\n          \n        }\n        \n        @autobind\n        fetchExternalConnections(){\n          \n          return new Promise(async (resolve,reject)=>{\n            \n            this.setState({\n              fetchingConnections: true\n            });\n            \n            let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n              type: 'standard_capability_action:0.0.1:local:298j291bs',\n              data: {\n                action: 'send',\n                options: {\n                  ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                  RequestNode: {\n                    type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                    data: {\n                      actions: [\n                        {\n                          matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                          dataForAction: {\n                            type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                            data: {\n                              matchFunctionNode: {\n                                // query here!\n                                // action_pointer:0.0.1:local:238972ncr\n                                type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                data: {\n                                  code: `(()=>{\n                                    // Action \n                                    // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                    \n                                    let inputNode = INPUT.data.inputNode;\n                                    \n                                    if(inputNode.nodeId){\n                                      return false;\n                                    }\n                                    \n                                    if(inputNode.type.split(':')[0] != 'external_identity'){\n                                      return false;\n                                    }\n                                    \n                                    return inputNode;\n                                    \n                                  })()`\n                                }\n                              },\n                              // expected/allowed schemas for return \n                              // outputSchemas: [\n                              //   'query_result:0.0.1:local:32490usfj23o23f',\n                              //   'internal_error_output:0.0.1:local:32948x2u3cno2c'\n                              // ]\n                            }\n                          }\n                        }\n                      ]\n                      \n                    }\n                  }\n                }\n              }\n            });\n            \n            // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n            console.log('fetchExternalConnections Response:', response);\n            \n            let nodes = response.data.actionResponses[0].data;\n            \n            this.setState({\n              allExternalConnections: nodes,\n              fetchingConnections: false\n            }, this.updateGroupConnections);\n            \n            resolve(nodes);\n            \n            \n          });\n          \n        }\n        \n        @autobind\n        updateGroupConnections(){\n          \n          // Checks allExternalConnections for matches with selected identity \n          \n          return new Promise(async (resolve,reject)=>{\n            \n            if(!this.state.groupNode){\n              return false;\n            }\n            \n            let groupNode = this.state.groupNode;\n            \n            let groupConnections = [];\n            \n            for(let externalIdentity of this.state.allExternalConnections){\n              \n              // console.log('User:', externalIdentity);\n              \n              let externalParsed = (externalIdentity.data.identity || ':').split(':');\n              let idType = externalParsed[0];\n              let username = externalParsed[1];\n              let subname;\n              let usernameSplit = username.split('@');\n              if(usernameSplit.length > 1){\n                subname = usernameSplit[0];\n                username = usernameSplit[1];\n              }\n              \n              console.log('UserParsed:', idType, subname, '@', username);\n              \n              // Evaluate against Group conditions \n              // - order matters! \n              let allow = false;\n              \n              for(let filter of groupNode.data.identities){\n                \n                console.log('identityFilter:', filter);\n                \n                switch(filter.type.split(':')[0]){\n                  case 'identity_range': // implied: \"allow\"\n                    // Check matching \n                    if(filter.data.idType == idType){\n                      if(filter.data.username == '*' || filter.data.username == username){\n                        if((!filter.data.subname && !subname) || (filter.data.subname == '*' || filter.data.subname == subname)){\n                          allow = true;\n                        }\n                      }\n                    }\n                    break;\n                  \n                  case 'identity_range_deny': \n                    // Check matching \n                    if(filter.data.idType == idType){\n                      if(filter.data.username == '*' || filter.data.username == username){\n                        if((!filter.data.subname && !subname) || (filter.data.subname == '*' || filter.data.subname == subname)){\n                          allow = false;\n                        }\n                      }\n                    }\n                    break;\n                    \n                  default:\n                    console.error('Invalid identity_range type for matching!');\n                    break;\n                }\n                \n              }\n              \n              if(allow){\n                groupConnections.push(externalIdentity);\n              }\n              \n            }\n            \n            this.setState({\n              groupConnections\n            });\n            \n            \n          });\n          \n        }\n        \n        @autobind\n        handleViewGroup(groupNode){\n          this.setState({\n            groupNode\n          },this.updateGroupConnections);\n        }\n        \n        @autobind\n        handleAddGroup(){\n          \n          return new Promise(async (resolve,reject)=>{\n            \n            let name = WINDOW.prompt('Group Name:','');\n            if(!name || !name.length){\n              return false;\n            }\n            \n            let newNode = {\n              name: universe.uuidv4(),\n              nodeId: null,\n              type: 'group_for_sharing:Qmsdfkljfsdsf2',\n              data: {\n                name,\n                key: universe.uuidv4(),\n                identities: [] // list of nodes for filtering identities (might be enumerated, might be \"all of xyz\" or regex)\n              }\n            }\n      \n            console.log('newNode:', newNode);\n      \n            let savedNode = await this.forceNewNode(newNode, {skipExistingLearnedNodeId: true}, true);\n            \n            await this.fetchGroups();\n            \n          });\n            \n        }\n        \n        @autobind\n        handleAddToGroup(groupNode, includeOrExclude){\n          \n          // Update a group with a new identity \n          // - modifies a group in-place \n          \n          return new Promise(async (resolve,reject)=>{\n            \n            // Get type of restriction for group \n            // - who to allow/deny for inclusion \n            //   - matched identities or provided info (token provided) \n            \n            let matchType;\n            // let matchType = WINDOW.prompt('match type (identity_range):','identity_range');\n            // if(!matchType){\n            //   return false;\n            // }\n            \n            let idType = WINDOW.prompt('idType (id, idtest, * for anything):','*');\n            if(typeof idType != 'string'){\n              return false\n            }\n            let username = WINDOW.prompt('username (* for anything, subname@username):','*');\n            if(typeof username != 'string'){\n              return false\n            }\n            \n            let subname = ''; // empty is for root \n            let usernameSplit = username.split('@');\n            if(usernameSplit.length > 1){\n              subname = usernameSplit[0];\n              username = usernameSplit[1];\n            }\n            \n            if(username == '*'){\n              subname = '*';\n            }\n            \n            matchType = \"identity_range:Qmsfljlkjs329f\";\n            if(includeOrExclude == 'exclude'){\n              matchType = \"identity_range_deny:Qmsdfj9823jf923f\";\n            }\n            \n            // only \"identity_range\" types for now \n            let matchNode = {\n              type: matchType, \n              data: {\n                idType,\n                username,\n                subname\n              }\n            }\n            \n            groupNode.data.identities.push(matchNode);\n            \n            console.log('Updating groupNode:', groupNode);\n            \n            \n            let updatedNode = await this.makeSaveRequest(groupNode);\n            \n            await this.fetchGroups();\n            \n          });\n            \n        }\n        \n        @autobind\n        forceNewNode(nodeToSave, opts, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            console.log('NewNode:', nodeToSave);\n                \n            // return resolve({\n            //   saveNewNode: nodeToSave\n            // });\n            \n            \n            // Make request to save Node on remote \n            try {\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                            dataForAction: {\n                              type: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                              data: {\n                                optionsNode: {\n                                  type: 'options_generic:0.0.1:local:289f3j29832',\n                                  data: opts || {}\n                                },\n                                dataNode: nodeToSave\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('NewNode response:', response);\n              \n              // get the new node \n              let savedNode = response.data.actionResponses[0];\n              \n              // console.log('Saved Node:', savedNode);\n              \n              if(skipEvent !== true){\n                try {\n                  universe.EE.emit('nodes-modified', '');\n                }catch(err){\n                  console.error(err);\n                }\n              }\n              \n              return resolve(savedNode);\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              // alert('Failed');\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        makeSaveRequest(nodeToSave, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            this.setState({\n              saving: true\n            })\n            \n            // Make request to save Node on remote \n            try {\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'update_node:0.0.1:local:392821982y3',\n                            dataForAction: {\n                              type: 'node:0.0.1:local:123445',\n                              data: nodeToSave\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('Update response:', response);\n              \n              if(skipEvent !== true){\n                try {\n                  universe.EE.emit('nodes-modified', '');\n                }catch(err){\n                  console.error(err);\n                }\n              }\n              \n              this.setState({\n                saving: false\n              })\n              \n              return resolve({\n                type: 'node:...',\n                data: response.data.actionResponses[0]\n              });\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              alert('Failed');\n              \n              this.setState({\n                saving: false\n              })\n              \n              return reject();\n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        renderGroups(){\n          return this.state.groups.map(groupNode=>{\n            return (\n              <div key={groupNode._id}>\n              \n                <h3 className=\"title is-5\" onClick={e=>this.handleViewGroup(groupNode)}>\n                  {groupNode.data.name}\n                </h3>\n                \n                <br />\n                \n              </div>\n            )\n          });\n        }\n        \n        @autobind\n        renderGroup(){\n          // Render info for the selected group \n            \n          if(!this.state.groupNode){\n            return '';\n          }\n          \n          let groupNode = this.state.groupNode;\n          \n          return (\n            <div>\n            \n              <h3 className=\"title is-3\">\n                {groupNode.data.name}\n              </h3>\n              <h3 className=\"subtitle is-5\">\n                {groupNode.data.key}\n              </h3>\n              \n                \n              <div>\n              \n                <button className=\"button is-default is-small\" onClick={e=>this.handleAddToGroup(groupNode)}>\n                  Add New Member (or Group Filter) \n                </button>\n                \n                \n                <div>\n                  {\n                    (groupNode.data.identities || []).map((identityFilter,idx)=>{\n                      switch(identityFilter.type.split(':')[0]){\n                        case 'identity_range':\n                          // include subname?\n                          if(identityFilter.data.subname){\n                            return(\n                              <div key={idx}>\n                                \n                                <div className=\"tags has-addons\">\n                                  <span className=\"tag is-light\">{identityFilter.data.idType}</span>\n                                  <span className=\"tag is-light\">:</span>\n                                  <span className=\"tag is-light\">{identityFilter.data.subname}</span>\n                                  <span className=\"tag is-light\">@</span>\n                                  <span className=\"tag is-light\">{identityFilter.data.username}</span>\n                                  <a className=\"tag is-delete\"></a>\n                                </div>\n\n                              </div>\n                            )\n                          } else {\n                            return(\n                              <div key={idx}>\n                                \n                                <div className=\"tags has-addons\">\n                                  <span className=\"tag is-light\">{identityFilter.data.idType}</span>\n                                  <span className=\"tag is-light\">:</span>\n                                  <span className=\"tag  is-light\">{identityFilter.data.username}</span>\n                                  <a className=\"tag is-delete\"></a>\n                                </div>\n\n                              </div>\n                            )\n                          }\n                          \n                        default:\n                          return (\n                            <div key={idx}>\n                              Invalid Filter Type\n                            </div>\n                          )\n                      }\n                    })\n                  }\n                </div>\n                \n                <hr />\n                \n                <div>\n                    \n                  <h3 className=\"title is-5\">\n                    Connections in Group \n                  </h3>\n                  <h3 className=\"subtitle is-6\">\n                    <Link to=\"/connections\">\n                      view connections\n                    </Link>\n                  </h3>\n                  \n                  <div>\n                    {\n                      !this.state.fetchingConnections ? '':\n                      <div className=\"field has-addons\">\n                        <div className=\"control\">\n                          <button className=\"button\">\n                            Fetching Connections\n                          </button>\n                        </div>\n                        <div className=\"control\">\n                          <a className=\"button is-loading\">\n                            &nbsp;\n                          </a>\n                        </div>\n                      </div>\n                    }\n                    {\n                      this.state.groupConnections.map((ExternalIdentityNode)=>(\n                        <div>\n                          Name: <Link to={\"/connections/\" + ExternalIdentityNode.data.identity}>{ExternalIdentityNode.data.identity}</Link>\n                        </div>\n                      ))\n                    }\n                  </div>\n                  \n                </div>\n                  \n              </div>\n              \n            </div>\n          )\n          \n        }\n        \n        render(){\n          \n          return (\n            <div className=\"container\">\n              <div className=\"columns\">\n                <div className=\"column is-6\">\n                \n                  <br />\n                  \n                  <h2>\n                    <button className=\"button is-info\" onClick={this.handleAddGroup}>\n                      + Group\n                    </button>\n                    <hr />\n                    <div className=\"field has-addons\">\n                      <div className=\"control\">\n                        <button className=\"button\" onClick={this.fetchGroups}>\n                          Fetch All Groups\n                        </button>\n                      </div>\n                      {\n                        !this.state.fetchingGroups ? '':\n                        <div className=\"control\">\n                          <a className=\"button is-loading\">\n                            &nbsp;\n                          </a>\n                        </div>\n                      }\n                    </div>\n                  </h2>\n                  \n                  <br />\n                  \n                  <div>\n                    {\n                      this.renderGroups()\n                    }\n                  </div>\n                  \n                </div>\n                \n                <div className=\"column is-6\">\n                  {\n                    this.renderGroup()\n                  }\n                </div>\n                \n              </div>\n              \n            </div>\n          )\n        }\n      }\n      \n      mycomponent = universe.ReactGlobalState(mycomponent);\n      mycomponent = universe.ReactHelpers(mycomponent);\n      \n      const styles = {\n        deleteIcon: {\n          position: 'absolute',\n          top: '0px',\n          right: '-24px',\n          cursor: 'pointer'\n        }\n      }\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: mycomponent\n      });\n      \n    }catch(err){\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()",
    "internalId": "MainGroupsComponent"
  }
}