{
  "type": "code:0.0.1:local:32498h32f2",
  "name": "code",
  "data": {
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // ONLY FOR: user_default\n      \n      // handles an incoming Node from the Universe \n      // - handles the majority of request types:\n      //   - first request (only seeded) \n      //   - web request \n      //   - internal heartbeat \n      //   - internal \"wakeup\" \n      \n      // This accepts a Node that defines the type of data it is, and how we should start handling the request \n      // - the \"if I know nothing, learn things\" command is in here as well \n      \n      switch(INPUT.type){\n        \n        case 'incoming_first:0.1.1:local:78882h37':\n        \n          // Determine if environment if browser, cloud, app\n          // - determine if we ask for what to download? \n          \n          WINDOW.alert('Not using this incoming_first anymore, using SetupComponent instead');\n          return false;\n          \n          // This is called only once, after \"learnBasics\" populated default Nodes \n          // - basic capabilities are included/available  \n          \n          // Need to create a local Identity, and authenticate with the remote Second to Learn from \n          // - uses a constant value (token) from the remote Second! \n          let newIdentityNode = await universe.loadAndRunCapability('Identity',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'createLocal',\n              options: {}\n            }\n          });\n          \n          \n          // Find remote Second \n          // - hash of keywords -> wallet address -> encrypted via last keyword? \n          // - want a publicKey and a URL returned \n          //   - a whole IdentityNode should be returned? \n          // - return: \n          //   - external_identity:0.0.1:local:8982f982j92\n          //   - external_identity_connect_method:0.0.1:local:382989239hsdfmn\n          \n          let remoteValue;\n          try {\n            remoteValue = WINDOW.prompt('Remote Second','test21 test21');\n          }catch(err){\n            console.error('Not in Tab');\n            remoteValue = 'test test';\n          }\n          \n          console.log('Words to use for ExternalIdentity:', remoteValue);\n          \n          // Need to create a local Identity, and authenticate with the remote Second to Learn from \n          // - uses a constant value (token) from the remote Second! \n          let addressNode = await universe.loadAndRunCapability('Identity',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'getAddressForWords',\n              options: {\n                words: remoteValue\n              }\n            }\n          });\n          \n          let address = addressNode.data;\n          \n          // fetch that wallet address, get the first transaction \n          // - first transaction contains IPFS link \n          // - IPFS contains Nodes (without _ids!) \n          let foundExternalIdentityNode = await universe.getIdentityForAddress(address);\n          \n          console.log('Got foundExternalIdentityNode',foundExternalIdentityNode);\n          \n          // Save ExternalIdentityNode locally! \n          let ExternalIdentityNode = await universe.loadAndRunCapability('Identity',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'saveExternal',\n              options: {\n                ExternalIdentityNode: foundExternalIdentityNode // should contain a connection method! \n              }\n            }\n          });\n          \n          // Update local node commonName (for easy lookup) \n          ExternalIdentityNode.data.commonName = 'main';\n          let updatedExternal = await universe.updateNode(ExternalIdentityNode);\n          \n          \n          console.log('Saved new ExternalIdentityNode', ExternalIdentityNode);\n          \n          // await universe.newNode(ExternalIdentityNode);\n          \n          // return resolve({\n          //   ExternalIdentityNode,\n          //   error: true,\n          //   remoteValue,\n          //   address\n          // })\n          \n          \n          let internalUserPassphrase;\n          try {\n            internalUserPassphrase = WINDOW.prompt('Internal User Passphrase','testuserpassphrase');\n          }catch(err){\n            console.error('Not in Tab');\n            internalUserPassphrase = 'testuserpassphrase';\n          }\n          \n          \n          \n          // Identify and Upgrade connection as an InternalUser (using passphrase) \n          // - this uses the newly-created ExternalIdentityNode user \n          // - also upgrades our local data.token \n          \n          try {\n            \n          // Authenticate with External Second \n          // - make authenticated requests to a Second (necessary for Learning?) \n          //   - should have ALL requests authenticated \n          // universe.setupExternalSecond();\n            \n            // Initiating Identify ...again\n            let authExternalIdentityNode2 = await universe.loadAndRunCapability('IdentifyInitiate',{},{\n              type: 'standard_capability_action:0.0.1:local:298j291bs',\n              data: {\n                action: 'start',\n                options: {\n                  externalIdentityPublicKey: ExternalIdentityNode.data.publicKey,\n                  // authToken: 'eeaac41bdb1b717d137a53779db97457:07e0fbe19e72c3ff7e329fc293bcf5b51d780c4c3c60f80403b2fea8f30d0daa5e4891dbdd6c57d9844622078a681853f31202d0632f0ee95031c9369a60708ddb6220e248e3c2ec6b3bb3c00eb2425aea922351d7128ef333ea5fe6a8ad139c1978759e29b057db1e655f2fe7c8962e' // \"learn\" \n                }\n              }\n            });\n            \n            console.log('Finished IdentifyInitiate2. Starting IdentifyActAsInternalUser');\n          \n            let actAsNode = await universe.loadAndRunCapability('IdentifyActAsInternalUser',{},{\n              type: 'standard_capability_action:0.0.1:local:298j291bs',\n              data: {\n                action: 'start',\n                options: {\n                  externalIdentityPublicKey: ExternalIdentityNode.data.publicKey,\n                  internalUserPassphrase\n                }\n              }\n            });\n            console.log('Finished Upgrading local identity with ActAs. actAsNode Response', actAsNode);\n            \n            \n            // Test new user (am I really ActAs?) \\\n            let e2Nodes = await universe.searchMemory({\n              filter: {\n                sqlFilter: {\n                  nodeId: null,\n                  type: 'external_identity:0.0.1:local:8982f982j92',\n                  data: {\n                    publicKey: ExternalIdentityNode.data.publicKey\n                  }\n                }\n              }\n            });\n            let e2node = e2Nodes[0];\n            \n            console.log('e2node:', e2node);\n            \n            let e2response = await universe.loadAndRunCapability('TalkToSecond',{},{\n              type: 'standard_capability_action:0.0.1:local:298j291bs',\n              data: {\n                action: 'send',\n                options: {\n                  ExternalIdentityNode: e2node,\n                  RequestNode: {\n                    type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                    data: {\n                      actions: [\n                              \n                        {\n                          matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                          dataForAction: {\n                            type: 'string:...',\n                            data: e2node.data.token\n                          }\n                        },\n                        \n                        // {\n                        //   matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                        //   dataForAction: {\n                        //     type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                        //     data: {}\n                        //   }\n                        // }\n                      ]\n                      \n                    }\n                  }\n                }\n              }\n            });\n            \n            console.log('e2response',e2response);\n            \n          }catch(err){\n            console.error('Failed actAsNode upgrade',err);\n          }\n          \n          \n          \n          return resolve({\n            externalResponse: true,\n            // response,\n            codeResultNode,\n            // localResult\n          })\n          \n          \n          // let IdentityNode = null;\n          // let identities = await universe.searchMemory({\n          //   filter: {\n          //     sqlFilter: {\n          //       type: 'remote_datasource:0.0.1:local:298f3h92hf9s8dhf23f'\n          //     },\n          //     // function for returning data from the Node, after filtering a bit \n          //     // - includes both the Node, and Nodes with nodeId (pointers) \n          //     filterNodes: tmpNodes=>{\n          //       // this runs isolated, outside of the above context? (not sure) \n          //       return new Promise((resolve, reject)=>{\n          //         resolve(tmpNodes);\n          //       });\n          //     },\n          //   }\n          // });\n          \n          \n          break;\n          \n        case 'incoming_wakeup:0.0.1:local:8923yf89h9h':\n          // Wakeup \n          // - handles loading capabilities that will be used later \n          //   - loads all Capabilities (require things in?), adds them to GlobalCache \n          //   - on subsequent requests, universe.capabilities() should work. \n          \n          break;\n          \n        case 'incoming_heartbeat:0.0.1:local:23849u492348c7n9':\n          // Heartbeat (ever 1 second or so is expected) \n          break;\n          \n          \n        case 'incoming_web_request:0.0.1:local:29832398h4723':\n          // http or websocket requeust \n          // - headers and body are included\n          //   - body is JSON (expected to be!) \n        \n          \n          // expecting a full express.req object in INPUT \n          // - headers, paths, body, etc. \n          \n          let expressNode, headers, body, urlPath;\n          \n          switch(INPUT.data.type.split(':')[0]){\n            \n            case 'socketio_obj':\n              console.log('incoming_from_uni got SOCKETIO request!');\n          \n              // clientId = INPUT.data.data.clientId\n              console.log('Websocket ClientId:', INPUT.data.data.clientId);\n              await universe.setRequestCacheKeyValue('wsClientId', INPUT.data.data.clientId);\n              \n              // await universe.httpResponse('send', {\n              //   type: 'testing_response:Qmsfdj', \n              //   data: {RESPONSE: 'test2'}\n              // });\n              expressNode = INPUT.data; // socketio_obj \n              headers = {};\n              body = INPUT.data.data.data; \n              urlPath = '/ai';\n              \n              // update expressNode for websocket \n              expressNode.data.body = body;\n              \n              // Find and use the \"ai\" route/action \n              \n              \n              \n              // return resolve({\n              //   type: 'boolean:Qmdsflj',\n              //   data: true\n              // });\n              break;\n              \n              \n            case 'websocket_obj':\n              console.log('incoming_from_uni got WEBSOCKET request!');\n              \n              let wsData = INPUT.data.data;\n              let wsMsg;\n              \n              // wsData  = {\n              //   type: // message, connection, close\n              //   msg: {type: 'request|response'} or null,\n              //   clientId // universe.wsClients\n              // }\n              \n              // only handle 'message' here, for now \n              if(wsData.type != 'message'){\n                console.log('Type not message, ignored by incoming_from_uni:', wsData.type);\n                return resolve({});\n              }\n              \n              console.log('Type from WebSocket IS \"message\"', wsData.type);\n                            \n              // \tif(typeof wsData.msg != 'object'){\n              // \t\tconsole.error('Did NOT receive an object for websocket request!', typeof wsData.msg);\n              // \t\tconsole.log(wsData.msg);\n              // \t\treturn;\n              // \t}\n              \n              if(typeof wsData.msg == 'string'){\n                try {\n                  wsMsg = JSON.parse(wsData.msg);\n                }catch(err){\n                  console.error('Invalid wsMsg');\n                  wsMsg = {};\n                }\n              } else {\n                wsMsg = wsData.msg;\n              }\n              \n              console.log('wsMsg:', typeof wsMsg, wsMsg);\n          \n            \t// MUST be either a request|response type \n            \tswitch(wsMsg.type){\n            \t\tcase 'request':\n          \n                  console.log('Incoming REQUEST from websocket');\n                  console.log('WEBSOCKET REQUEST DATA:', JSON.stringify(wsMsg.data, null, 2));\n                  console.log('Setting wsRequestId:', wsMsg.requestId);\n          \n                  // TODO: do something, then send a response via universe.httpResponse (todo: GenericResponse) \n                  await universe.setRequestCacheKeyValue('wsRequestId',wsMsg.requestId);\n                  await universe.sleep(1000);\n                  console.log('Responding (after sleep)');\n                  await universe.httpResponse('send', {\n                    type: 'testing_response:Qmsfdj', \n                    data: {test: 'test1'}\n                  });\n                  \n                  \n                  // pass off to another \"code\" capability, for ease-of-programming? \n          \n            \t\t\tbreak;\n          \n            \t\tcase 'response': // NOT USED, using callback functions (acknowledgements) as data transport \n            \t    // emit response to eventemitter, will be picked up by whatever made the request \n            \t\t\t// - TODO: have map of valid request Ids, prevent duplicate responses, etc. \n            \t\t\tconsole.log('Accepting response to my request (from RPI)', 'wsMsg.requestId:', wsMsg.requestId);\n                  // universe.eventEmitter.emit(`ws-response-${wsMsg.requestId}`, wsMsg.data);\n            \t\t\tbreak;\n          \n            \t\tdefault:\n            \t\t  console.error('Invalid type from websocket message!');\n            \t\t\tbreak;\n            \t}\n            \t\n              return resolve({\n                type: 'boolean:Qmdsflj',\n                data: true\n              });\n              \n              \n            case 'express_obj':\n              // Express HTTP Request (default) \n              \n              expressNode = INPUT.data; // INPUT.data.type == 'express_obj:Qmdsfkljsl'\n              \n              headers = expressNode.data.req.headers;\n              body = expressNode.data.req.body;\n              urlPath = expressNode.data.req.path;\n              \n              break;\n              \n              \n            default:\n              console.error('Failed INPUT.data.type for incoming_web_request');\n              return resolve({\n                type: 'invalid_internal_type:Qmsdfisf',\n                data: false\n              });\n          }\n          \n          \n          // console.log('BODY:', JSON.stringify(body,null,2));\n          // console.log('ExpressNode:', universe.cJSON.stringify(expressNode,null,2));\n          \n          \n          // Load routes, controllers for each (TODO) \n          // - MVC-like for web requests, expecting most non-node requests to be authentication one-offs \n          \n          \n          // cache the route-finding code \n          let cacheAppId = universe.getParentRoot(SELF)._id;\n          let cache = ['incoming_web_request_route_nodes', cacheAppId].join('|');\n          \n          // app root-level (old: global-root) \n          let routeNodes = await universe.searchMemory({\n            cache,\n            filter: {\n              sqlFilter: {\n                // nodeId: null // OLD: root-level\n                type: 'incoming_route_handler:Qmsdfkj329j3'\n              },\n              // function for returning data from the Node, after filtering a bit \n              // - includes both the Node, and Nodes with nodeId (pointers) \n              filterNodes: tmpNodes=>{\n                // this runs isolated, outside of the above context? (not sure..think it is same context though [using INPUT.data.type in search]) \n                return new Promise((resolve, reject)=>{\n                  tmpNodes = tmpNodes.filter(tmpNode=>{\n                    // see if has a ChildNode matching a type \n                    \n                    if(!universe.sameAppPlatform(SELF, tmpNode)){\n                      // console.log('FOUND IT UNDER SAME APP!!!!!', tmpNode._id);\n                      return false;\n                    }\n                    \n                    return true;\n                    \n                  });\n                  resolve(tmpNodes);\n                });\n              },\n            }\n          });\n          \n          console.log('Sort routes');\n          \n          // prevent \"/ai\" from being pushed to the bottom! \n          // - mucking with /ai will cause some serious problems! \n          \n          let routes = routeNodes.sort((a,b)=>{\n            try {\n                // multiple /ai's?\n              if(a.data.ai && !b.data.ai){\n                return -1;\n              }\n              if(b.data.ai && !a.data.ai){\n                return 1;\n              }\n              return (a.data.priority > b.data.priority) ? 1:-1; // lower priority => checked first!\n            }catch(err){\n              console.error('err sorting routes:', err);\n              return 0;\n            }\n          }).map(routeNode=>{\n            // get codeNode to run \n            let routeTxtMatches = routeNode.data.routes || []; // multiple allowed \n            \n            let routeCodeNodeToRun = universe.lodash.find(routeNode.nodes,{type:'code:0.0.1:local:32498h32f2'});\n            \n            return [routeTxtMatches, routeCodeNodeToRun];\n          });\n          \n          console.log('Checking routes', routes.length);\n          \n          // // print out routes to check (order\n          // for(let route1 of routes){\n          //   console.log('ROUTECheck1:',JSON.stringify(route1[0]));\n          // }\n          \n          let routed = false;\n          for(let route of routes){\n            if(routed){continue}\n            for(let tmpMatchRoute of route[0]){\n              if(routed){continue}\n              let tmpRoute = new universe.RouteParser(tmpMatchRoute);\n              let match = tmpRoute.match(urlPath)\n              if(match){\n                routed = true;\n                \n                console.log('MATCH ROUTE:', match ? true:false, tmpMatchRoute, match);\n                \n                // update expressNode with params\n                expressNode.data.params = match;\n                \n                // run in vm, and pass in the inputSchema Node! \n                // - of the action! (expecting/requiring it to be a Node w/ code....how to verify that? logic vs data?) \n                let routeResult;\n                try {\n                  console.log('Getting routeResult');\n                  routeResult = await universe.runNodeCodeInVM({\n                    codeNode: route[1], // includes type/schemaName and data \n                    dataNode: expressNode, // passes express obj, with req, res \n                    timeout: 15 * 1000\n                  });\n                }catch(err){\n                  return resolve('FAILED code from incoming_web_request, trying to run route');\n                }\n                \n                console.log('executed route, expecting to have already responded using expressNode.data.res.send()');\n                return resolve({\n                  type: 'executed_route:Qmmf3290jhgj',\n                  data: true\n                });\n                \n              }\n            }\n          }\n          \n          if(!routed){\n            console.log('No Matches');\n            await universe.httpResponse('send','404 - Missing Page');\n            return resolve({\n              type: 'missing_route:Qm404sfhsf',\n              data: false\n            });\n          }\n            \n          break;\n          \n        case 'incoming_web_request_blob:0.0.1:local:293h98h92f3':\n          // todo: handle incoming Blob data \n          break;\n          \n        case 'incoming_web_request_websocket:0.0.1:local:293h98h92f3':\n          // todo: handle incoming websocket request \n          // - could also be on browser? \n          break;\n          \n        case 'incoming_browser_request:0.0.1:local:829329329f832':\n          // incoming request (if in a browser) \n          // - expecting INPUT.type.data is a node! \n          // - might be actions, or something else \n            \n            \n          let nodes = await universe.searchMemory({\n            filter: {\n              filterNodes: tmpNodes=>{\n                // this runs isolated, outside of the above context? (not sure) \n                return new Promise((resolve, reject)=>{\n                  tmpNodes = tmpNodes.filter(tmpNode=>{\n                    // see if has a ChildNode matching a type \n                    let foundMatcherChild = universe.lodash.find(tmpNode.nodes || [],tmpChildNode=>{\n                      return tmpChildNode.type == 'incoming_query_type_matcher:0.0.1:local:3242rx23rd3';\n                    })\n                    // 'run_action:0.0.1:local:2398y294c23'\n                    if(!foundMatcherChild){\n                      return false;\n                    }\n                    \n                    return foundMatcherChild.data.typeMatch == INPUT.data.type;\n                  });\n                  resolve(tmpNodes);\n                });\n              },\n            }\n          });\n          \n          if(nodes && nodes.length){\n            // found Node to run for action! \n  \n            let codeNode = universe.lodash.find(nodes[0].nodes,{type:'code:0.0.1:local:32498h32f2'});\n            \n            // run in vm, and pass in the inputSchema Node! \n            // - of the action! (expecting/requiring it to be a Node w/ code....how to verify that? logic vs data?) \n            let actionResult;\n            try {\n              actionResult = await universe.runNodeCodeInVM({\n                codeNode,\n                dataNode: INPUT\n              });\n              \n              // ,{\n              //   codeNode, // includes type/schemaName and data \n              //   dataNode: INPUT, // should be another Node that can be used by the action! \n              //   timeout: 15 * 1000\n              // });\n            }catch(err){\n              return resolve('FAILED code from incoming_browser_request');\n            }\n            \n            // validate actionResult!\n            // - todo\n            \n            return resolve(actionResult);\n            // { \n            //   txt: 'Response:', \n            //   nodeTypes: nodes.map(n=>n.type),\n            //   actionResult\n            // }); // + result);\n            \n          } else {\n            // no Node found for handling action :( \n              \n            return resolve({ \n              error: 'No Nodes for action (incoming_browser_request)',\n              INPUT\n            }); // + result);\n          }\n          \n          \n          // switch(INPUT.data.type){\n            \n          //   case 'ping:0.0.1:local:239fh298fh239h23':\n          //     return resolve({\n          //       ping: 'pong'\n          //     });\n            \n          //   case 'browser_startup:0.0.1:local:8831167ssd':\n          //     // setting up initial component \n          //     let result = await universe.searchMemory({\n          //       filter: {\n          //         sqlFilter: {\n          //           type: 'react_component:0.0.1:local:98912hd89',\n          //           data: {\n          //             internalId: 'MainComponent'\n          //           }\n          //         }\n          //       }\n          //     });\n          //     let componentNode = await universe.runInVM(result[0],{});\n              \n          //     return resolve(componentNode);\n            \n          //   default:\n          //     break;\n          // }\n          \n          break;\n          \n          \n        default:\n          break;\n      }\n\n      return resolve({\n        type: 'err:..',\n        data: {\n          msg: 'Missing valid input type'\n        }\n      });\n      \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()",
    "key": "a9c55c9a-327f-46ba-938c-2237fba25eae"
  }
}