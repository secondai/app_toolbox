{
  "type": "react_component:0.0.1:local:98912hd89",
  "name": "MainComponent",
  "data": {
    "author": "-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCcuXovU+RZy85KMqLakYSH1mdV\nWdpEUtgcXUyGyU5hVeTO7BkV/kxeC2upcxOwNnrBOdsvHI3nrrILgt90/hCSHKzx\nhOFLREorGoKtSEHxI7/SnzzlWtV3gT/IP5GVHIyvuJBx3hCti0dH55DZG8iMGZ2y\ncGpV73Dez3hHmeBh6wIDAQAB\n-----END PUBLIC KEY-----",
    "version": "2",
    "key": "3ae95ba5-2d74-4fa4-846d-768b503c398b",
    "code": "(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      const AceEditor = universe.AceEditor;\n      const ReactResizeDetector = universe.ReactResizeDetector;\n      const RecreateChildOnPropsChange = universe.RecreateChildOnPropsChange;\n      \n      const Router = universe.ReactRouterDomRouter;\n      const Route = universe.ReactRouterDomRoute;\n      const Switch = universe.ReactRouterDomSwitch;\n      \n      class EmbeddedComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              embeddedComponenthere\n            </div>\n          )\n        }\n      }\n      \n      let ErrorComponent = (name) => {\n        return class ErrorComponent extends React.Component {\n          constructor(props){\n            super(props);\n          }\n          render(){\n            return (\n              <div>\n                ErrorLoading: {name || 'unknown'}\n              </div>\n            )\n          }\n        }\n      }\n      \n      class mycomponent extends React.Component {\n        constructor(props){\n          super(props);\n          \n          WINDOW.appBaseUrl = WINDOW.appBaseUrl || '/toolbox';\n          \n          this.state = {\n            basicLoginPassphrase: '',\n            loginType: 'basic',\n            loginUrl: '/auth/google?onlogin=' + WINDOW.appBaseUrl\n          }\n          \n          WINDOW.UpdateApp = this.handleUpdateApp;\n          \n        }\n        \n        componentDidMount(){\n          \n          console.log('MainComponent didMount');\n          \n          this.startUp();\n            \n            \n        }\n        \n        @autobind\n        async startUp(){\n          \n          // Fetch default nodes (Language NodeChain, Identity, etc.) \n          await this.fetchDefaultNodes();\n          \n          await this.loadComponents();\n          \n          // if identity includes a logged-in profile\n          // - show the main page \n          // - else: \n          //   - see if hash exists in url (token, after login) \n          //   - redirect to login if no hash to process\n          await this.processLogin();\n          \n          this.setupWebsockets();\n          \n          console.log('MainComponent loaded startUp');\n        \n        }\n        \n        @autobind\n        async handleUpdateApp(){\n          \n          // update local app_base from remote app_base \n          // - updates each node, according to name/path (NOT id) \n          \n          this.props.setState({\n            updatingLocal: true\n          });\n          \n          let localAppBases = await universe.searchMemory({\n            filter: {\n              filterNodes: tmpNodes=>{\n                // this runs isolated, outside of the above context? (not sure) \n                return new Promise((resolve, reject)=>{\n                  tmpNodes = tmpNodes.filter(tmpNode=>{\n                    if(tmpNode.nodeId){\n                      return false;\n                    }\n                    if(tmpNode.type.split(':')[0] != 'app_base'){\n                      return false;\n                    }\n                    return true;\n                  });\n                  resolve(tmpNodes);\n                });\n              },\n            }\n          });\n          let localAppBase = localAppBases[0];\n          \n          console.log('localAppBase:',localAppBase);\n          \n          // Get app_base from remote \n          let remoteAppBaseNode;\n          let remoteNodes;\n        \n          try {\n            \n            // use specified app, or determine from connected-to app? \n            // - usually specified now \n            if(WINDOW.limitedToAppZip){\n              // using specified\n              remoteNodes = await this.fetchNodesFromUrl(WINDOW.limitedToAppZip);\n              \n            } else {\n              // NOT specified (find, then run) \n              \n              let findResponse = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                            dataForAction: {\n                              type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              data: {\n                                matchFunctionNode: {\n                                  // query here!\n                                  // action_pointer:0.0.1:local:238972ncr\n                                  type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                  data: {\n                                    code: `(()=>{\n                                      // Action \n                                      // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                      \n                                      let inputNode = INPUT.data.inputNode;\n                                      \n                                      if(inputNode.nodeId){\n                                        return false;\n                                      }\n                                      \n                                      if(inputNode.type.split(':')[0] != 'app_base'){\n                                        return false;\n                                      }\n                                      if(inputNode.name != '${localAppBase.name}'){\n                                        return false;\n                                      }\n                                      \n                                      // Only return children platform_nodes for \"browser\" \n                                      inputNode.nodes = inputNode.nodes.filter(node=>{\n                                        if(node.type.split(':')[0] == 'platform_nodes' && \n                                          node.data.platform != 'browser'){\n                                            return false;\n                                        }\n                                        return true;\n                                      });\n                                      \n                                      return inputNode;\n                                      \n                                    })()`\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              remoteNodes = findResponse.data.actionResponses[0].data;\n            }\n            \n            // expecting a single result!\n            remoteAppBaseNode = remoteNodes[0];\n            \n            console.log('App nodes on Remote:', remoteNodes);\n            \n          }catch(err){\n            console.error('Failed getting local nodes');\n            return;\n          }\n          \n          \n          // Delete local app_base\n          console.log('Delete localAppBase');\n          await universe.removeNode(localAppBase._id);\n          \n          // Forcing updates at the moment (overwriting local app_base entirely) \n          // - TODO: show a diff! \n          // - TODO: only overwrite platform_nodes where platform=browser ? \n          \n              \n          console.log('Save remoteAppBase to local');\n          const saveChildNodes = (nodeId, childNodes) => {\n            return new Promise(async (resolve, reject)=>{\n    \n              console.log('Saving children');\n              \n              for(let tmpNode of childNodes){\n                let newChildNode = {\n                  nodeId,\n                  name: tmpNode.name,\n                  type: tmpNode.type,\n                  data: tmpNode.data,\n                }\n                let savedChildNode = await universe.newNode(newChildNode);\n                console.log('savedChildNode', savedChildNode);\n                if(tmpNode.nodes && tmpNode.nodes.length){\n    \n                  await saveChildNodes(savedChildNode._id, tmpNode.nodes || []);\n    \n                }\n              }\n              resolve();\n            });\n          }\n          await saveChildNodes(null, [remoteAppBaseNode]);\n          \n          console.log('Completed local update');\n          \n          this.props.setState({\n            updatingLocal: false\n          });\n          \n          // Could reload all? \n          // let answer = WINDOW.prompt('Reload?');\n          // if(answer){\n            setTimeout(()=>{\n              WINDOW.location.reload();\n            },1000);\n          // }\n          \n        }\n        \n        @autobind\n        fetchNodesFromUrl(url){\n          \n          // returns [expected: app_base] nodes from URL \n          \n          return new Promise(async (resolve,reject)=>{\n            \n            // converts startup git url into username/password \n            // - eventually allow links to be pasted, parse accordingly \n            \n            let ZipNodes;\n            \n            // parse github links and re-organize to fit .zip model \n        \n            this.setState({\n              fetchingNodes: true\n            });\n            \n            if(url.indexOf('github') > -1){\n\n              \n              let gh = universe.parseGitHubUrl(url);\n              if(gh.owner && \n                gh.name && \n                gh.repo && \n                gh.branch){\n                url = `https://github.com/${gh.repo}/archive/${gh.branch}.zip`;\n              }\n          \n              // cannot simply follow github zipball/tarball links :( \n              universe.fetch(`https://cors-anywhere.herokuapp.com/${url}`,{\n                // mode: 'no-cors' \n              })\n              .then(response=>{\n                // console.log('Response:', response);\n                return response.arrayBuffer();\n              })\n              .then(universe.JSZip.loadAsync)\n              .then(async (zip)=>{\n                \n                console.log('loaded zip data!', zip);\n        \n                // ZIP is valid! \n                let files = zip.files;\n        \n                function readFilePath(p){\n                  return new Promise(async (resolve,reject)=>{\n                    console.log('path:', p);\n                    let r = await files[p].async('text')\n                    resolve(r);\n                  });\n                }\n        \n                // load all the files \n                let allFiles = {};\n                for(let filepath of Object.keys(files)){\n                  let file = files[filepath];\n                  if(file.dir){\n        \n                  } else {\n                    // console.log('filepath:', filepath);\n                    let contents = await readFilePath(filepath);\n                    // console.log('contents:', contents);\n                    let normalizedPath = filepath.split('/').splice(1).join('/');\n                    allFiles[normalizedPath] = contents;\n                  }\n                }\n        \n                console.log('allFiles from Zip:', allFiles);\n                \n                function addChildren(id){\n                  return new Promise(async (resolve,reject)=>{\n              \n                    let nodes = [];\n                      for(let filepath of Object.keys(allFiles)){\n                      let contents = allFiles[filepath];\n                      if(filepath.indexOf('nodes/') !== 0){\n                        // console.log('NOT NODE:', filepath);\n                        continue;\n                      }\n        \n                      let parsed = jsonParse(filepath, contents);\n                      if(parsed.nodeId == id){\n                        // console.log('Matches ID:', parsed.nodeId, id);\n                        let children = await addChildren(parsed._id);\n                        parsed.nodes = children;\n                        nodes.push(parsed);\n                      } else {\n                        // console.log('No Kids:', id, parsed.nodeId);\n                      }\n        \n                    }\n        \n                    resolve(nodes);\n        \n                  });\n                }\n        \n                // re-organize child nodes \n                try {\n                  ZipNodes = await addChildren(null); // start at root, adds children recursively \n                }catch(err){\n                  console.error('Failed zipnodes', err);\n                  WINDOW.alert('Failed fetching zip nodes');\n                }\n          \n                console.log('ZipNodes:', ZipNodes);\n                \n                // let secondJson = JSON.parse(allFiles['second.json']);\n                // let basicKey = secondJson.name; \n                \n                this.setState({\n                  fetchingNodes: false\n                });\n                \n                return resolve(ZipNodes);\n        \n              })\n              \n            } else {\n              \n              console.log('Fetching second-hosted app url');\n        \n              // second-hosted app url \n              // - NOT zipped! \n              universe.fetch(url,{\n                // mode: 'no-cors' \n              })\n              .then(response=>{\n                console.log('Second App Response:', response);\n                // return response.arrayBuffer();\n                return response.json();\n              })\n              .then(appBaseJson=>{\n                console.log('appBaseJson', appBaseJson);\n        \n                ZipNodes = [appBaseJson];\n                    \n                this.setState({\n                  fetchingNodes: false\n                });\n                \n                return resolve(ZipNodes);\n                \n              });\n            }\n\n            \n          });\n          \n        }\n        \n        @autobind\n        processLogin(){\n          // handling multiple starting states \n          \n          return new Promise(async (resolve,reject)=>{\n              \n            // update the token for the local user\n            let OwnerSecondExternalIdentityNode = this.props.state.OwnerSecondExternalIdentityNode;\n            if(!OwnerSecondExternalIdentityNode){\n              console.error('Uh oh, missing OwnerSecondExternalIdentityNode');\n              return;\n            }\n            \n            if(OwnerSecondExternalIdentityNode.data.isLoggedIn){\n              // all good\n              console.log('All good, has identity!');\n              \n              return resolve(true);\n              // return;\n              \n            } else {\n              // not logged in yet, might be processing incoming hash/token \n              let hash = WINDOW.location.hash;\n              \n              let newToken = (hash || '').split('token=');\n              console.log('newToken1', newToken);\n              if(newToken.length > 1){\n                newToken = newToken[newToken.length-1];\n              } else {\n                newToken = null;\n              }\n              \n              // clear hash \n              WINDOW.location.hash = '';\n              \n              if(!newToken){ \n                // no token, redirect to login \n                console.log('No token (before login!)');\n                \n                this.setState({\n                  renderLogin: true\n                });\n                \n                // prevents more components loading...\n                return false;\n                \n                \n              } else {\n                \n                // token in hash, processing login (after redirect) \n                console.log('newToken2', newToken);\n                \n                let passphrase = newToken;\n                try {\n                  let successfulLogin = await this.loginWithPassphrase(passphrase);\n                }catch(err){\n                  return resolve(false);\n                }\n                \n                // finished upgrading local token \n                return resolve(true);\n                \n                \n              }\n              \n            }\n          \n          });\n        \n          \n        }\n        \n        @autobind\n        loginWithPassphrase(passphrase){\n          return new Promise(async (resolve,reject)=>{\n            \n            // Authenticate with External Second \n            // - make authenticated requests to a Second (necessary for Learning?) \n            //   - should have ALL requests authenticated \n            // universe.setupExternalSecond();\n            \n            try {\n              \n              // get connection target \n              let OwnerSecondExternalIdentityNode = this.props.state.OwnerSecondExternalIdentityNode;\n              if(!OwnerSecondExternalIdentityNode){\n                console.error('Uh oh, missing OwnerSecondExternalIdentityNode');\n                return reject(false);\n              }\n            \n              // Run the entire authentication handshake with the pre-existing ExternalIdentity Node \n              // - creates external_identity on remote \n              // - updates external_identity locally ( in browser), to include \"token\" (encrypted {} on remote) \n              let authExternalIdentityNode2 = await universe.loadAndRunCapability('IdentifyInitiate',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'start',\n                  options: {\n                    externalIdentityPublicKey: OwnerSecondExternalIdentityNode.data.publicKey,\n                    // authToken: 'eeaac41bdb1b717d137a53779db97457:07e0fbe19e72c3ff7e329fc293bcf5b51d780c4c3c60f80403b2fea8f30d0daa5e4891dbdd6c57d9844622078a681853f31202d0632f0ee95031c9369a60708ddb6220e248e3c2ec6b3bb3c00eb2425aea922351d7128ef333ea5fe6a8ad139c1978759e29b057db1e655f2fe7c8962e' // \"learn\" \n                  }\n                }\n              });\n              \n              console.log('Finished IdentifyInitiate2. Starting IdentifyActAsInternalUser');\n              \n              // Update the local external_identity.data.token \n              // - doesnt change anything on the remote! \n              // - only changes the local encrypted \"token\" to included an internalUserId (gets new token from remote. token not stored anywhere) \n              let actAsNode = await universe.loadAndRunCapability('IdentifyActAsInternalUser',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'start',\n                  options: {\n                    externalIdentityPublicKey: OwnerSecondExternalIdentityNode.data.publicKey,\n                    internalUserPassphrase: passphrase\n                  }\n                }\n              });\n              // Check type\n              if(actAsNode.type.indexOf('identity_upgrade_finish:') !== 0){\n                throw \"Failed Login\"\n              }\n              console.log('Finished Upgrading local identity with ActAs. actAsNode Response', actAsNode);\n            }catch(err){\n              console.error('Failed upgrading ActAs after login');\n              WINDOW.alert('Failed login, please try again');\n              return reject(false); // TODO: error message \n            }\n            \n            // re-fetch OwnerSecondExternalIdentityNode after being updated! \n            // - otherwise, overwrites \"actas\" changes \n            await this.fetchDefaultNodes();\n            OwnerSecondExternalIdentityNode = this.props.state.OwnerSecondExternalIdentityNode;\n            \n            // Update OwnerSecondExternalIdentityNode.data.isLoggedIn\n            OwnerSecondExternalIdentityNode.data.isLoggedIn = true;\n            await universe.updateNode(OwnerSecondExternalIdentityNode);\n            \n            this.props.setState({\n              OwnerSecondExternalIdentityNode\n            });\n            \n            console.log('Updated OwnerSecondExternalIdentityNode');\n            \n            return resolve(true);\n            \n          });\n        }\n        \n        @autobind\n        async setupWebsockets(){\n          // setup socket.io client connection, for server->client commands/notifications (client is just another Second) \n          // - also useful for RPi \n          \n          if(this.props.state.OwnerSecondExternalIdentityNode &&\n             this.props.state.OwnerSecondExternalIdentityNode.data.isLoggedIn){\n            // is logged in\n            \n            universe.setTimeout(async ()=>{\n              console.log('Setting up WebSockets (calling capability)');\n              \n              let doneSetup = await universe.loadAndRunCapability('Websockets',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'initLink',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode\n                  }\n                }\n              });\n            },5000);\n            \n            \n          } else {\n            console.log('NOT setting up Websockets');\n          }\n        }\n        \n        @autobind\n        async loadComponents(){\n          \n          // Not async for setState! \n          \n          let components = [\n            'DefaultLayout',\n            'MainHomeComponent',\n            'MainPackedNodeRouteComponent',\n            'MainGroupsComponent',\n            'MainConnectionsComponent',\n            'Main404Component'\n          ];\n          \n          for(let componentInternalId of components){\n            try {\n                \n              let Component = await this.props.loadComponent({\n                internalId: componentInternalId\n              });\n              let obj = {};\n              obj[componentInternalId] = Component;\n              this.setState(obj)\n              // console.log(componentInternalId,Component);\n              \n            }catch(err){\n              console.error(\"Failed loading component:\",componentInternalId);\n            }\n          }\n          \n        }\n        \n        @autobind\n        fetchDefaultNodes(){\n          // nodes used elsewhere in the app \n          \n          return new Promise(async (resolve,reject)=>{\n              \n            // Cloud Second's main identity, from internal \n            let ExternalIdentityNodes = await universe.searchMemory({\n              filter: {\n                sqlFilter: {\n                  type: 'external_identity:0.0.1:local:8982f982j92',\n                  data: {\n                    commonName: 'main'\n                  }\n                }\n              }\n            });\n            let OwnerSecondExternalIdentityNode = ExternalIdentityNodes[0];\n            \n            this.props.setState({\n              OwnerSecondExternalIdentityNode\n            }, resolve);\n            \n          });\n          \n        }\n        \n        @autobind\n        processBasicLogin(){\n          \n          return new Promise(async (resolve,reject)=>{\n            \n            if(this.state.tryingBasicLogin){\n              return resolve(false);\n            }\n            \n            this.setState({\n              tryingBasicLogin: true\n            });\n          \n                  \n            try {\n              let successfulLogin = await this.loginWithPassphrase(this.state.basicLoginPassphrase);\n              if(successfulLogin){\n                // reload page? \n                // - automatic? \n                this.setState({\n                  renderLogin: false\n                });\n              }\n            }catch(err){\n              this.setState({\n                tryingBasicLogin: false\n              });\n              return resolve(false);\n            }\n            \n            this.setState({\n              tryingBasicLogin: false\n            });\n            \n          });\n          \n        }\n        \n        @autobind\n        handleKeyDown(e){\n          if(e.key && e.key.toLowerCase() == 'enter'){\n            this.processBasicLogin();\n          } \n        }\n        \n        @autobind\n        handleLoginClick(){\n          this.processBasicLogin();\n        }\n        \n        @autobind\n        renderLoginComponent(){\n          \n          switch(this.state.loginType){\n            case 'basic':\n            \n              return (\n                <div className=\"section\">\n                  <div className=\"container\">\n                    <div className=\"columns\">\n                      <div className=\"column is-4 is-offset-4\">\n                      \n                        <h3 className=\"title is-4\">\n                          Toolbox\n                        </h3>\n                        <h3 className=\"subtitle is-6\">\n                          Login to manage this Second \n                        </h3>\n                        <div>\n                          <input className=\"input\" type=\"text\" placeholder=\"Passphrase\" value={this.state.basicLoginPassphrase} onChange={e=>this.setState({basicLoginPassphrase:e.target.value})} onKeyDown={this.handleKeyDown} />\n                        </div>\n                        <br />\n                        <div>\n                          <span className={\"button is-info \" + (this.state.tryingBasicLogin ? 'is-loading':'')} onClick={this.handleLoginClick}>\n                            Login\n                          </span>\n                        </div>\n                        \n                      </div>\n                    </div>\n                  </div>\n                </div>\n              );\n              \n            case 'google-oauth':\n              \n              return (\n                <div className=\"section\">\n                  <div className=\"container\">\n                    <div className=\"columns\">\n                      <div className=\"column is-4 is-offset-4\">\n                      \n                        <h3 className=\"title is-4\">\n                          Toolbox\n                        </h3>\n                        <h3 className=\"subtitle is-6\">\n                          Login to manage this Second \n                        </h3>\n                        <a className=\"button is-info\" href={this.state.loginUrl}>\n                          Login using Google \n                        </a>\n                        \n                      </div>\n                    </div>\n                  </div>\n                </div>\n              );\n            \n            default:\n                \n              return (\n                <div className=\"section\">\n                  <div className=\"container\">\n                    <div className=\"columns\">\n                      <div className=\"column is-4 is-offset-4\">\n                      \n                        <h3 className=\"title is-4\">\n                          Toolbox\n                        </h3>\n                        <h3 className=\"subtitle is-6\">\n                          Login type has not been defined\n                        </h3>\n                        \n                      </div>\n                    </div>\n                  </div>\n                </div>\n              );\n              \n          }\n            \n        }\n        \n        render(){\n          \n          const DefaultLayout = this.state.DefaultLayout || ErrorComponent('DefaultLayout');\n          const MainHomeComponent = this.state.MainHomeComponent || ErrorComponent('MainHomeComponent');\n          const MainGroupsComponent = this.state.MainGroupsComponent || ErrorComponent('MainGroupsComponent');\n          const MainConnectionsComponent = this.state.MainConnectionsComponent || ErrorComponent('MainConnectionsComponent');\n          const MainPackedNodeRouteComponent = this.state.MainPackedNodeRouteComponent || ErrorComponent('MainPackedNodeRouteComponent');\n          const Main404Component = this.state.Main404Component || ErrorComponent('Main404Component');\n          \n          if(this.state.renderLogin){\n            return this.renderLoginComponent();\n          }\n          \n          return (\n            <Router basename={WINDOW.appBaseUrl}>\n              <Switch>\n              \n                <DefaultLayout exact path=\"/\" component={MainHomeComponent} />\n                <DefaultLayout exact path=\"/node\" component={MainPackedNodeRouteComponent}/>\n                <DefaultLayout exact path=\"/groups\" component={MainGroupsComponent}/>\n                <DefaultLayout exact path=\"/connections\" component={MainConnectionsComponent}/>\n                \n                {/* Fallback (404) */}\n                <DefaultLayout path=\"/\" component={Main404Component} />\n                \n              </Switch>\n            </Router>\n          )\n        }\n      }\n      \n      mycomponent = universe.ReactGlobalState(mycomponent);\n      mycomponent = universe.ReactHelpers(mycomponent);\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: mycomponent\n      });\n      \n    }catch(err){\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()",
    "internalId": "MainComponent"
  }
}