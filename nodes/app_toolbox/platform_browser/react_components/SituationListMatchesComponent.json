{
  "type": "react_component:0.0.1:local:98912hd89",
  "name": "SituationListMatchesComponent",
  "data": {
    "author": "-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCcuXovU+RZy85KMqLakYSH1mdV\nWdpEUtgcXUyGyU5hVeTO7BkV/kxeC2upcxOwNnrBOdsvHI3nrrILgt90/hCSHKzx\nhOFLREorGoKtSEHxI7/SnzzlWtV3gT/IP5GVHIyvuJBx3hCti0dH55DZG8iMGZ2y\ncGpV73Dez3hHmeBh6wIDAQAB\n-----END PUBLIC KEY-----",
    "version": "1",
    "key": "46996b80-fdd8-48b5-94a4-758311aa21dd",
    "code": "(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      const AceEditor = universe.AceEditor;\n      const ReactResizeDetector = universe.ReactResizeDetector;\n      const RecreateChildOnPropsChange = universe.RecreateChildOnPropsChange;\n      \n      const Select = universe.ReactSelect;\n      \n      const ReactSortableContainer = universe.ReactSortableContainer;\n      const ReactSortableElement = universe.ReactSortableElement;\n      const ReactSortableArrayMove = universe.ReactSortableArrayMove;\n      \n      class SortableItem extends React.Component {\n        constructor(props){\n          super(props);\n          \n          let node = this.props.value;\n          \n          this.state = {\n            node,\n            editing: false,\n          }\n        }\n        \n        componentDidMount(){\n          this.handleKeyDown();\n        }\n        \n        componentWillReceiveProps(nextProps){\n          this.setState({\n            node: nextProps.value\n          });\n        }\n        \n        \n        @autobind\n        startEditing(){\n          console.log('startEditing', this.state.node);\n          \n          let query;\n          try {\n            query = JSON.stringify(JSON.parse(this.state.node.data.query), null, 2);\n          }catch(err){\n            console.error('invalid query value! not a string (should have been):', this.state.node, err);\n            query = 'ERROR!'\n          }\n          \n          this.setState({\n            editing: true,\n            plain: this.state.node.data.plain,\n            value: query\n          });\n        }\n        \n        @autobind\n        closeEditor(){\n          this.setState({\n            editing: false\n          });\n        }\n        \n        @autobind\n        handleSave(){\n          console.log('saving');\n          \n          // Verify it is an object (not an array) \n          let query;\n          let value = this.state.value;\n          try {\n            // todo: dirty-json! \n            query = JSON.stringify(JSON.parse(value));\n          }catch(err){\n            console.error('Invalid JSON');\n            WINDOW.alert('Invalid JSON');\n            return false;\n          }\n          \n          console.log('Query:', query);\n          \n          let node = this.state.node;\n          node.data.plain = this.state.plain;\n          node.data.query = query;\n          \n          this.props.makeSaveRequest(node);\n          \n          this.setState({\n            editing: false\n          });\n          \n        }\n      \n        @autobind\n        handleKeyDown(e){\n          if(this.aceRef && this.aceRef.editor){\n            this.aceRef.editor.commands.addCommand({\n              name: 'save',\n              bindKey: {\n                win: 'Ctrl-S',\n                mac: 'Command-S'\n              },\n              exec: (env, args, request)=>{\n                this.handleSave();\n              }\n            });\n            \n            // overwrite Cmd-D to same as sublime \n            this.aceRef.editor.commands.addCommand({\n              name: 'selectMoreAfter2',\n              bindKey: {\n                win: 'Ctrl-D',\n                mac: 'Command-D'\n              },\n              exec: (env, args, request)=>{\n                // selectMoreAfter\n                this.aceRef.editor.execCommand(\"selectMoreAfter\")\n              }\n            });\n          }\n      \n        }\n        \n        @autobind\n        handleDelete(){\n          \n          let node = this.state.node;\n          \n          this.props.makeDeleteRequest(node);\n          \n        }\n        \n        render(){\n          let node = this.state.node;\n          \n          return (\n            <div>\n              { !this.state.editing ? \n                <div style={{cursor:'pointer'}}>\n                  {(node.data.position || 0) + 1}. \"{\n                    node.data.plain\n                  }\" <span className='icon' onClick={this.startEditing}><i className='fa fa-edit'></i></span>\n                  <span className='icon' onClick={this.handleDelete}><i className='fa fa-trash'></i></span>\n                </div>\n              :\n              <div>\n                <input type=\"text\" value={this.state.plain} onChange={e=>this.setState({plain:e.target.value})} className=\"input\" />\n                <br />\n                <div style={{height: '300px'}}>\n                  <AceEditor\n                    ref={r=>this.aceRef=r}\n                    mode=\"jsx\"\n                    theme=\"monokai\"\n                    value={this.state.value}\n                    onChange={value=>{\n                      this.setState({value});\n                    }}\n                    editorProps={{$blockScrolling: true}}\n                    width=\"100%\"\n                    height=\"100%\"\n                    onLoad={editor=>{\n                      editor.getSession().setUseWrapMode(true);\n                    }}\n                    setOptions={{\n                      enableBasicAutocompletion: true,\n                      enableLiveAutocompletion: true,\n                      showPrintMargin: false,\n                      enableSnippets: true,\n                      behavioursEnabled: false,\n                      showLineNumbers: true,\n                      tabSize: 2\n                    }}\n                  />\n                </div>\n                \n                <div className=\"field is-grouped\">\n                  <p className=\"control\">\n                    <button className=\"button is-success\" onClick={this.handleSave}>\n                      Save\n                    </button>\n                  </p>\n                  <p className=\"control\">  \n                    <button className=\"button is-default\" onClick={this.closeEditor}>\n                      Cancel\n                    </button>\n                  </p>\n                </div>\n                \n              </div>\n              }\n              \n            </div>\n          )\n        }\n      }\n                    \n      SortableItem = ReactSortableElement(SortableItem);\n           \n      class SortableList extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              {this.props.items.map((value, index) => (\n                <SortableItem \n                  key={`item-${index}`} \n                  index={index} \n                  value={value} \n                  makeSaveRequest={this.props.makeSaveRequest}\n                  makeDeleteRequest={this.props.makeDeleteRequest}\n                />\n              ))}\n            </div>\n          );\n        }\n      }\n      \n      SortableList = ReactSortableContainer(SortableList); //({items}) => {\n      \n      // SortableList = universe.sharedComponents.withEditableNodeInfo(SortableList, {\n      //   editNodePath: 'app_toolbox/platform_browser/react_components/DefaultLayout',\n      //   editNodeId: '5af76ca59c4742002112b884'\n      // });   \n      \n      \n    \n      class mycomponent extends React.Component {\n        constructor(props){\n          super(props);\n          \n          this.state = {\n            options: [],\n            value: null, // Select.Creatable value (value.node if existing) \n            queryValue: null\n          }\n          \n        }\n        \n        componentDidMount(){\n          if(this.props.initEditComponent){\n            this.props.initEditComponent(this);\n          }\n          \n          this.fetchPossibleMatches();\n        }\n        \n        @autobind\n        getBuilderNodes(){\n          \n          let builder = universe.lodash.query(this.props.situationMatchActionNode.nodes,{\n            type: {\n              $like: 'situation_match_builder:'\n            }\n          });\n          if(!builder.length){\n            // no matches!\n            return (<div>No Matches</div>);\n          }\n          builder = builder[0];\n          \n          let builderNodes = builder.nodes.sort((a,b)=>{\n            return (a.data.position - b.data.position)\n          });\n          \n          return builderNodes;\n          \n        }\n        \n        @autobind\n        fetchPossibleMatches(){\n          // get all posibilities for \"situation_match_builder\" nodes \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n              \n              this.setState({\n                fetchingMatches: true\n              })\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          \n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                      \n                          {\n                            matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                            dataForAction: {\n                              type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              data: {\n                                dataFilter: {\n                                  'parent.type' : {\n                                    $like: 'situation_match_builder:'\n                                  }\n                                },\n                                matchFunctionNode: null\n                              }\n                            }\n                          }\n                          \n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              let nodes = response.data.actionResponses[1].data;\n              \n              // Create trees from nodes (in_reply_to) \n              // - get all of my unique Posts \n              let PossibleMatchNodes = nodes;\n              \n              \n              console.log('PossibleMatchNodes', PossibleMatchNodes);\n              \n              let options = PossibleMatchNodes.map(node=>{\n                return {\n                  label: node.data.plain,\n                  value: node._id,\n                  node\n                }\n              })\n              \n              // let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                PossibleMatchNodes,\n                options\n              })\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n            }\n          \n            this.setState({\n              fetchingMatches: false\n            })\n            \n          });\n          \n        }\n        \n        @autobind\n        onSortStartMatches(){\n          console.log('Sort started!');\n        }\n        \n        @autobind\n        onSortEndMatches(indexes, newIndex){\n          // console.log('ended sort', oldIndex, newIndex);\n          \n          // // Update each node's position, if changed\n          // let builderNodes = JSON.parse(JSON.stringify(this.state.builderNodes));\n          // // let tmpOut = builderNodes.slice(oldIndex);\n          // let gotNode = builderNodes.splice(oldIndex,1);\n          // console.log('SplicedGotNode:', oldIndex, newIndex, gotNode); //gotNode.data.plain, gotNode);\n          // // builderNodes.splice(newIndex,0,tmpOut[0]);\n          // // builderNodes.push(tmpOut[0]);\n          \n          let builderNodes = ReactSortableArrayMove(this.getBuilderNodes(), indexes.oldIndex, indexes.newIndex);\n          \n          // console.log('Now builderNodes', oldIndex, newIndex, builderNodes);\n          \n          let toSave = [];\n          \n          builderNodes = builderNodes.map((node,position)=>{\n            console.log(position, node.data.plain, node);\n            if(node.data.position != position){\n              node.data.position = position;\n              toSave.push(node);\n            }\n            return node;\n          });\n          \n          console.log('toSave:', toSave.length, toSave);\n          for(let nodeToSave of toSave){\n            this.makeSaveRequest(nodeToSave);\n          }\n          \n          // this.setState({\n          //   builderNodes\n          // });\n          \n          // TODO: save changed! \n          \n        }\n        \n        @autobind\n      \thandleOnChangeNew(value){\n      \t  \n      \t  if(!value){\n      \t    return this.setState({value});\n      \t  }\n      \t  \n      \t  \n      \t // console.log('VALUE:', value);\n      \t \n      \t  // new or existing?\n      \t  if(value.node){\n      \t    // existing \n      \t  } else {\n      \t    // new\n      \t    value.node = {\n      \t      data: {\n      \t        plain: value.label,\n      \t        query: \"{}\",\n      \t      }\n      \t    }\n          }\n      \t  \n          let queryValue;\n          try {\n            queryValue = JSON.stringify(JSON.parse(value.node.data.query), null, 2);\n          }catch(err){\n            console.error('invalid query value! not a string (should have been):', this.state.node, err);\n            queryValue = 'ERROR!'\n          }\n          \n      \t\tthis.setState({ \n      \t\t  value,\n      \t\t  queryValue\n      \t\t});\n      \t}\n        \n        @autobind\n        async handleCreateMatchBuilderNode(){\n          \n          // Add a node to the match builder \n          console.log('handleCreateMatchBuilderNode');\n          let builder = universe.lodash.query(this.props.situationMatchActionNode.nodes,{\n            type: {\n              $like: 'situation_match_builder:'\n            }\n          });\n          if(!builder.length){\n            // no matches!\n            return console.error('Missing situation_match_builder');\n          }\n          builder = builder[0];\n          \n          console.log('builder', builder);\n          \n          let query;\n          try {\n            // todo: dirty-json! \n            query = JSON.stringify(JSON.parse(this.state.queryValue));\n          }catch(err){\n            console.error('Invalid JSON');\n            WINDOW.alert('Invalid JSON');\n            return false;\n          }\n          \n          \n          let node = {\n            nodeId: builder._id,\n            name: universe.uuidv4(),\n            type: 'match_temp:Qmsldfj',\n            data: {\n              plain: this.state.value.node.data.plain,\n              query,\n              position: builder.nodes.length\n            }\n          }\n          \n          console.log('Creating:', node);\n          \n          let createNodeResponse = await this.createNodeOnSecond(node);\n          \n          console.log('createNodeResponse',createNodeResponse);\n          \n          \n          this.setState({\n            value: null,\n            queryValue: null\n          });\n          \n          if(this.props.onUpdate){\n            this.props.onUpdate();\n          }\n          \n        }\n        \n        @autobind\n        async handleCompileMatch(){\n          // compile match_builder nodes into single query for matching \n          // - TODO: handle server-side, with ML \n          \n          // Add a node to the match builder \n          console.log('handleCompileMatch');\n          let existingMatchNode = universe.lodash.query(this.props.situationMatchActionNode.nodes,{\n            type: {\n              $like: 'situation_match:'\n            }\n          });\n          if(!existingMatchNode.length){\n            // no matches!\n            return console.error('Missing existing situation_match');\n          }\n          existingMatchNode = existingMatchNode[0];\n          \n          \n          let builder = universe.lodash.query(this.props.situationMatchActionNode.nodes,{\n            type: {\n              $like: 'situation_match_builder:'\n            }\n          });\n          if(!builder.length){\n            // no matches!\n            return console.error('Missing situation_match_builder');\n          }\n          builder = builder[0];\n          \n          let builderNodes = builder.nodes.sort((a,b)=>{\n            return (a.data.position - b.data.position)\n          });\n          \n          let queries = builderNodes.map(builderNode=>{\n            return JSON.parse(builderNode.data.query);\n          });\n          \n          existingMatchNode.data.query = JSON.stringify({\n            $and: queries\n          })\n          \n          console.log('Saving existingMatchNode', existingMatchNode);\n          \n          await this.makeSaveRequest(existingMatchNode);\n          \n          \n        }\n        \n        @autobind\n        makeSaveRequest(nodeToSave, opts, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            this.setState({\n              saving: true\n            })\n            \n            opts = opts || {};\n            \n            // Make request to save Node on remote \n            try {\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                          {\n                            matchActionType: 'update_node:0.0.2:local:392821982y3',\n                            dataForAction: {\n                              type: 'update_node_data:0.0.2:local:123445',\n                              data: {\n                                optionsNode: {\n                                  type: 'options_generic:0.0.1:local:289f3j29832',\n                                  data: opts || {}\n                                },\n                                dataNode: nodeToSave\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('Update response:', response);\n              \n              if(skipEvent !== true){\n                try {\n                  universe.EE.emit('nodes-modified', '');\n                }catch(err){\n                  console.error(err);\n                }\n              }\n              \n              this.setState({\n                saving: false\n              })\n              \n              return resolve({\n                type: 'node:...',\n                data: response.data.actionResponses[1]\n              });\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              alert('Failed');\n              \n              this.setState({\n                saving: false\n              })\n              \n              return reject();\n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        async makeDeleteRequest(node){\n          // removes from list also \n          \n          node.active = false;\n          \n          await this.makeSaveRequest(node);\n          \n          // Update positions of builder nodes\n          let builderNodes = this.getBuilderNodes();\n          universe.lodash.remove(builderNodes, n=>{\n            return n._id == node._id;\n          });\n          \n          \n          // console.log('Now builderNodes', oldIndex, newIndex, builderNodes);\n          \n          let toSave = [];\n          \n          builderNodes = builderNodes.map((node,position)=>{\n            console.log(position, node.data.plain, node);\n            if(node.data.position != position){\n              node.data.position = position;\n              toSave.push(node);\n            }\n            return node;\n          });\n          \n          console.log('toSave:', toSave.length, toSave);\n          for(let nodeToSave of toSave){\n            await this.makeSaveRequest(nodeToSave);\n          }\n          \n          console.log('After save, update selected');\n          \n          if(this.props.onUpdate){\n            this.props.onUpdate();\n          }\n          \n        }\n        \n        @autobind\n        createNodeOnSecond(nodeToSave){\n          return new Promise(async (resolve, reject) => {\n            \n            console.log('NewNode:', nodeToSave);\n                \n            // Make request to save Node on remote \n            try {\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          \n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                          \n                          {\n                            matchActionType: 'create_node:Qmf3892j39f8h9babb',\n                            dataForAction: {\n                              type: 'create_node_data:Qmdslkfj29f0j82',\n                              data: {\n                                optionsNode: {\n                                  type: 'options_generic:0.0.1:local:289f3j29832',\n                                  data: {}\n                                },\n                                dataNode: nodeToSave\n                              }\n                            }\n                          }\n                        ]\n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('create_node response:', response);\n              \n              // get the created node \n              let savedNode = response.data.actionResponses[1];\n              \n              return resolve(savedNode);\n              \n            } catch(err){\n              console.error('Failed creating new node', err);\n            }\n            \n          })\n        }\n        \n        render(){\n          \n          let builderNodes = this.getBuilderNodes();\n          \n          // this.setState({\n          //   builderNodes\n          // });\n          // let builderNodes = this.state.builderNodes;\n          \n          return (\n            <div>\n              <link rel=\"stylesheet\" type=\"text/css\" href='https://unpkg.com/react-select@1.2.1/dist/react-select.css' />\n              \n              <SortableList \n                items={builderNodes} \n                pressDelay={150}\n                onSortStart={this.onSortStartMatches} \n                onSortEnd={this.onSortEndMatches} \n                makeSaveRequest={this.makeSaveRequest}\n                makeDeleteRequest={this.makeDeleteRequest}\n              />\n              \n              <br />\n              <div>\n                \n                <Select.Creatable\n        \t\t\t\t\tmulti={false}\n        \t\t\t\t\toptions={this.state.options}\n        \t\t\t\t\tonChange={this.handleOnChangeNew}\n        \t\t\t\t\tvalue={this.state.value}\n        \t\t\t\t\tshowNewOptionAtTop={true}\n        \t\t\t\t\topenOnClick={false}\n        \t\t\t\t/>\n        \t\t\t\t\n                { !this.state.queryValue ? '':\n                <div>\n                  <div style={{height: '300px'}}>\n                    <AceEditor\n                      ref={r=>this.aceRef=r}\n                      mode=\"jsx\"\n                      theme=\"monokai\"\n                      value={this.state.queryValue}\n                      onChange={queryValue=>{\n                        this.setState({queryValue});\n                      }}\n                      editorProps={{$blockScrolling: true}}\n                      width=\"100%\"\n                      height=\"100%\"\n                      onLoad={editor=>{\n                        editor.getSession().setUseWrapMode(true);\n                      }}\n                      setOptions={{\n                        enableBasicAutocompletion: true,\n                        enableLiveAutocompletion: true,\n                        showPrintMargin: false,\n                        enableSnippets: true,\n                        behavioursEnabled: false,\n                        showLineNumbers: true,\n                        tabSize: 2\n                      }}\n                    />\n                  </div>\n                </div>\n                }\n                \n                <button className=\"button is-success\" onClick={this.handleCreateMatchBuilderNode}>\n                  Save New\n                </button>\n                \n              </div>\n            </div>\n          )\n\n        }\n      }\n      \n      mycomponent = universe.sharedComponents.withEditableNodeInfo(mycomponent, {\n        localNode: SELF\n      });\n      \n      mycomponent = universe.ReactGlobalState(mycomponent);\n      mycomponent = universe.ReactHelpers(mycomponent);\n      mycomponent = universe.ReactRouterDomWithRouter(mycomponent);\n      \n            \n      const styles = {\n        deleteIcon: {\n          position: 'absolute',\n          top: '0px',\n          right: '-24px',\n          cursor: 'pointer'\n        }\n      }\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: mycomponent\n      });\n      \n    }catch(err){\n      console.error(err);\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()",
    "internalId": "SituationListMatchesComponent"
  }
}